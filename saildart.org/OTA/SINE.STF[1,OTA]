<!DOCTYPE html>
<html lang="en">
<head><link rel="stylesheet" href="https://www.saildart.org/css/u8.css" /><meta charset="utf-8" />
<title>SINE.STF[1,OTA] - www.SailDart.org</title>
</head>
<body id="u8body">
<div id="tagline">perm filename SINE.STF[1,OTA]  blob <a href="https://www.saildart.org/SINE.STF[1,OTA]_blob">sn#544890</a> filedate 1980-10-15 generic text, type T, neo UTF8</div>
<pre id="u8lump">
↑L 
     Listing of >s>langs>sine>sine.pl1  08/11/80 17:34:25

sine:     procedure;

%include tty←info;

 dcl gsti$get←tty←info entry (ptr,structure);
 dcl gsti$set←tty←info entry (ptr,structure);
 dcl linkage$user←input ptr external;
 dcl 1 saved←tty←info like tty←info;

 dcl hcs$initiate entry (char(168)vary,char(32)vary,pointer,fixed(31));
 dcl scs$ioa entry options (variable);
 dcl scs$expand←path entry (char(168)vary,char(168)vary,char(32)vary,fixed(31));

 dcl com←error entry options(variable);

 dcl sine←machine$interp entry (pointer);
 dcl sine←machine$initialize entry;

 dcl dname char(168) varying;
 dcl ename char(32) varying;
 dcl uname char(8) varying;
 dcl pgm←ptr pointer static;
 dcl code fixed(31);

 dcl scs$get←arg←count entry (fixed);
 dcl scs$get←arg←info entry (fixed,fixed,fixed,ptr);
 dcl scs$break←entry entry;

 dcl ap pointer;
 dcl arg char(al) based(ap);
 dcl at fixed;
 dcl al fixed;
 dcl nargs fixed;

 dcl first←time bit(1) static init("1"b);
 dcl (break, cleanup) condition;

     call scs$get←arg←count (nargs);
     if nargs = 0 then if first←time
          then do;
               call com←error(0,"sine","what program should be loaded?");
               return;
               end;
          else go to call←interp;
     call scs$get←arg←info (1,at,al,ap);
     call scs$expand←path (arg,dname,ename,code);
     ename = ename || ".sine";
     call hcs$initiate (dname,ename,pgm←ptr,code);
     if code &lt; 0 then do;
          call com←error(code,"sine","where is ↑a>↑a",dname,ename);
          return;
          end;
     if first←time then do;
          call sine←machine$initialize;
          first←time = "0"b;
          end;

call←interp:

     call gsti$get←tty←info (linkage$user←input,tty←info);
     saved←tty←info = tty←info;
     tty←info.echo←input = "0"b;
     call gsti$set←tty←info (linkage$user←input,tty←info);

     on break begin;
          call gsti$set←tty←info(linkage$user←input,saved←tty←info);
          call scs$break←entry;
          call gsti$set←tty←info (linkage$user←input,tty←info);
          end;

     on cleanup begin;
          call gsti$set←tty←info(linkage$user←input,saved←tty←info);
          end;

     call sine←machine$interp(pgm←ptr);
     signal cleanup;
     return;

end;  /* sine.pl1 */
↑L 
     Listing of >s>langs>sine>init.pl1  12/30/79 17:27:53

init:     proc(state,string←space←ptr);

%include state;
%include stack;
%include data←types;

 dcl scs$get←uname entry returns (char(8) varying);
 dcl com←error entry options(variable);
 dcl hcs$initiate entry (char(168)vary,char(32)vary,pointer,fixed(31));
 dcl hcs$append←seg entry (char(168)vary, char(32) vary, fixed(31));
 dcl hcs$terminate entry (pointer);
 dcl hcs$truncate←file entry (char(168)vary, char(32)vary, fixed, fixed(31));

 dcl uname char(8) varying;
 dcl ename char(32) varying;
 dcl dname char(168) varying;
 dcl code fixed(31);

 dcl stack←ptr pointer;
 dcl string←space←ptr pointer;

 dcl size builtin;

     uname = scs$get←uname();
     dname = ">process←dir>sine←segments";
     ename = uname || ".sine←stack";
     call hcs$append←seg (dname,ename,code);
     call hcs$truncate←file (dname,ename,0,code);
     call hcs$initiate(dname,ename,stack←ptr,code);
     if code &lt; 0 then do;
          call com←error(code,"sine","can't get stack segment");
          return;
          end;

     ename = uname || ".sine←string←space";
     call hcs$append←seg (dname,ename,code);
     call hcs$truncate←file (dname,ename,0,code);
     call hcs$initiate (dname,ename,string←space←ptr,code);
     if code &lt; 0 then do;
          call com←error (code,"sine","can't get string space");
          return;
          end;

     pc.buf = null();
     pc.loc = 0;
     sb = stack←ptr;
     sp = addrel(stack←ptr,size(frame)-8);  /* no temps yet */
     ip = null();
     frame.saved←pc.buf = null();
     frame.saved←pc.loc = 0;
     frame.saved←sb = null();
     frame.saved←sp = null();
     frame.saved←ip = null();
     frame.handlers = null();
     frame.num←args = 0;
     frame.num←temps = 0;
     frame.num←bound = 0;
     return;

haf: entry;              /* this Hacks Active Functions */

dcl scs$get←arg←count entry (fixed);
dcl scs$get←arg←info entry (fixed,fixed,fixed,ptr);
dcl $get←code←ptr entry returns(ptr);
dcl $pl1←allocate entry (fixed(31)) returns(ptr);

dcl ssp ptr;
dcl slen fixed(31);
dcl 1 sine←string based (ssp),
          2 len fixed,
          2 chars char(1);

dcl ap ptr;
dcl al fixed;
dcl arg char(al) based(ap);
dcl at fixed;
dcl nargs fixed;
dcl i fixed;
dcl j fixed;
dcl bb32 bit(32) based;

     call scs$get←arg←count (nargs);
     slen = -1;
     do i = 1 to nargs;
          call scs$get←arg←info(i,at,al,ap);
          slen = slen + al + 1;
          end;
     if slen = -1 then slen = 0;
     ssp = $pl1←allocate (slen+2);
     len = slen;
     j = 1;
     do i = 1 to nargs;
          call scs$get←arg←info(i,at,al,ap);
          substr(chars,j,al) = arg;
          j = j + al + 1;
          if i = nargs then leave;
          substr(chars,j-1,1) = " ";
          end;
     ap = $get←code←ptr();
     ap->bb32 = "20000000"b4 | unspec(ssp);
     return;

end;
↑L 
     Listing of >s>langs>sine>load.pl1  12/30/79 17:27:51

pl1←load: proc (state,code←ptr);

%include state;
%include stack;
%include data←types;

 dcl flag bit(1) init ("0"b);

 dcl code←ptr pointer;

 dcl size builtin;

 dcl tp pointer;
 dcl buf ptr;
 dcl ftp fixed(31) defined tp;
 dcl initial←ftp fixed(31);
 dcl initial←p ptr;
 dcl top←level pointer static init(null());
 dcl bfixed fixed based;
 dcl 1 entry based(tp),
          2 type fixed,
          2 len fixed,
          2 text char(1000);
 dcl fun pointer;
 dcl ip←area←ptr pointer;
 dcl ip←area(0:1) pointer based(ip←area←ptr);
 dcl fp ptr;
 dcl bp ptr;

 dcl code fixed(31);
 dcl (i,j) fixed;
 dcl blk←size fixed;
 dcl num fixed;
 dcl num←s fixed;
 dcl segno fixed;

 dcl $pl1←make←vbl entry (fixed,ptr,fixed(31));
 dcl $pl1←make←buffer entry (ptr,ptr);
 dcl $pl1←allocate entry (fixed(31),ptr);
 dcl $debug bit(1) external;
 dcl scs$ioa entry options(variable);

 dcl scs$allocn entry(fixed(31),ptr,area);
 dcl $error entry (char(8),structure);

common:
     tp = code←ptr;
     segno = baseno(tp);
     ftp = ftp + tp->bfixed;

     num = tp->bfixed;
     ftp = ftp + 2;
     if num = 0 then return;
     initial←ftp = ftp;

     call $pl1←make←buffer(buf,code←ptr);
     call $pl1←allocate (num*4+4,ip←area←ptr);
     unspec(ip←area←ptr) = unspec(ip←area←ptr) | "b0000000"b4;
     ftp = initial←ftp;

     do i = 1 to num;
          if entry.len = 0 then go to quit←out;
               /* no more vbl names: the rest are static */
          if entry.type &lt; 0
               then do;
                    call $pl1←allocate (2+entry.len,fp);
                    unspec(fp) = unspec(fp) | "20000000"b4;
                    fp->string.length = entry.len;
                    substr(fp->string.text,1,entry.len) =
                         substr(entry.text,1,entry.len);
                    end;
               else do;
                    if substr(entry.text,1,entry.len) = "!#$%&"
                         then do;
                              fp = null();
                              code = -1;
                              end;
                         else call $pl1←make←vbl (entry.len,fp,code);
                    if entry.type > 0
                         then do;   /* make a function */
                              call $pl1←allocate (size(function),fun);
                              fun->function.buf = buf;
                              fun->function.loc = entry.type*2;
                              fun->function.vbl←tab = ip←area←ptr;
                              unspec(fun) = unspec(fun) | "60000000"b4;
                              if fp = null()
                                   then fp = fun;
                                   else fp->variable.value = fun;
                              end;
                         else if code>=0 then fp->variable.value = null();
                    end;
          ip←area(i) = fp;

if $debug then call scs$ioa("↑i:↑a(↑p)-> ↑p",i,
     substr(entry.text,1,entry.len),fp,ptr(segno,entry.type*2));

          if substr(entry.text,1,entry.len) = "top←level"
               then top←level = ip←area(i);
          ftp = ftp + (entry.len+1)/2*2 + 4;
          end;

quit←out:
     num←s = num-i+1;
     ip←area(0) = ptr(num←s*4,num);
     if num←s > 0 then do i = num to num←s+1 by -1;
          ip←area(i) = ip←area(i-num←s);          /* copy the vbls up */
          end;
     if ↑flag then return;   /* just load: no special hacks */

     if top←level = null() then call $error("no top'l",state);
     frame.name←of←function = top←level->variable.name;
     tp = top←level->variable.value;
     pc.loc = tp->function.loc+2;
     pc.buf = buf;
     ip = tp->function.vbl←tab;
     frame.num←temps = addrel(code←ptr,pc.loc-2)->bfixed;
     sp = addrel(sb,size(frame)+(frame.num←temps-2)*4);
     return;

load←init:  entry(state,code←ptr);

 dcl already←here bit(1) static init("0"b);

     if already←here then return;
     already←here = "1"b;
     flag = "1"b;
     go to common;

end;
↑L 
     Listing of >s>langs>sine>sine←error.pl1 12/30/79 17:27:44

error:    proc(name,state,code←seg);

%include state;
%include stack;
%include data←types;

 dcl name char(8);
 dcl code←seg ptr;
 dcl scs$ioa entry options(variable);
 dcl scs$break←entry entry;
 dcl stty entry options(variable);
 dcl bchar char(1) based;
 dcl tp pointer;
 dcl fp pointer;
 dcl first←time bit(1) static init("1"b);

 dcl hcs$del←ref←name entry (char(32) varying);
 dcl hcs$initiate←w←options entry (char(168)varying,char(32)vary,char(32)vary,
     bit(1),ptr,fixed(31));
 dcl scs$find←gate←space entry (char(32)vary, char(4), char(4),ptr,fixed(31));
 dcl scs$get←uname entry returns(char(8)vary);
 dcl com←error entry options(variable);
 dcl scs$make←ptr entry (char(32)vary, char(32)vary, ptr,ptr,fixed(31));

 dcl code fixed(31));
 dcl uname char(8)varying;
 dcl ename char(32)varying;
 dcl dname char(168)vary;
 dcl nspace char(4);

     if first←time then do;
          first←time = "0"b;
          dname = ">process←dir>sine←segments";
          uname = scs$get←uname();
          ename = uname || ".sine←string←space";
          call scs$find←gate←space(ename,"    ",nspace,
               tp,code);
          if code &lt; 0 then do;
barf←out:      call com←error (code,"error");
               return;
               end;
          call hcs$initiate←w←options (dname,ename,ename,
               "1"b,tp,code);
          if code &lt; 0 then go to barf←out;
          ename = uname || ".sine←stack";
          call scs$find←gate←space(ename,nspace,nspace,tp,code);
          if code &lt; 0 then go to barf←out;
          call hcs$initiate←w←options (dname, ename, "sine←stack",
               "1"b,tp,code);
          if code &lt; 0 then go to barf←out;
          ename = "sine←machine";
          call scs$make←ptr (ename,"opcode←table",null(),op←tab←ptr,code);
          if code &lt; 0 then go to barf←out;
          call hcs$del←ref←name (ename);
          end;

start←over:
     call scs$ioa("↑rERROR: ↑a",name);
     call da (state,code←seg);
     call scs$ioa("↑rStack Trace:");
     do tp = state.sb repeat tp->frame.saved←sb while(tp ↑= null());
          fp = tp->frame.name←of←function;
          call scs$ioa("↑a",
               substr(fp->string.text,1,fp->string.length));
          end;
     call stty("echo","↑rawi");
     call scs$break←entry;
     go to start←over;

da:  entry (state,code←seg);

%include opcodes;

dcl 1 sine←machine$opcode←table (0:1) based(op←tab←ptr),
     2 arg←info (4) bit(16),
     2 inst←info fixed,
     2 inst←offset bit(16);
dcl op←tab←ptr ptr static;

dcl scs$ioa←nnl entry options(variable);

dcl vp ptr;
dcl reg←names (0:3) char(2) static init("pc","sb","sp","ip");
dcl op←index fixed;
dcl i fixed;
dcl base←reg fixed;
dcl offset fixed;
dcl boff bit(16) defined offset;
dcl pushp char(1);
dcl bb16 bit(16) based (tp);
dcl bp ptr based;
dcl bfixed fixed based;

     tp = addrel(code←seg,state.pc.loc-2);
     do while (substr(tp->bb16,1,3) ↑= "001"b);
          if rel(tp) = 0 then do;
               call scs$ioa("Executing total shit in segment ↑p",tp);
               return;
               end;
          tp = addrel(tp,-2);
          end;
     op←index = tp->bb16 & "0fff"b4;
     if substr(tp->bb16,4,1)
          then pushp = "-";
          else pushp = "+";
     do i = 1 to numops;
          if op←index = opcodes(i) then do;
               call scs$ioa←nnl("↑p: (↑a) ↑c ",tp,pushp,opname(i));
               go to gather←operands;
               end;
          end;
     call scs$ioa("↑p: opcode ↑i not found in table! recompile error.pl1?",
          tp,op←index);
     return;

gather←operands:
     do i = 1 to 4;
          tp = addrel(tp,2);
          if sine←machine$opcode←table(op←index).arg←info(i) = "0"b then leave;
          if ↑substr(tp->bb16,1,1)
               then call scs$ioa←nnl ("↑i, ",tp->bb16);
               else do;
                    base←reg = substr(bb16,2,2);
                    offset = substr(bb16,4,13);
                    if substr(boff,4,1) then substr(boff,1,3) = "111"b;
                    if base←reg = 0
                         then offset = offset*2;
                         else offset = offset*4;
                    if base←reg = 3
                         then do;
                              fp = addrel(state.ip,offset)->bp;
                              if offset &lt;= state.ip->bfixed then do;
                                   call scs$ioa←nnl("↑i(ip)=↑8w",offset,fp);
                                   continue;
                                   end;
                              vp = fp->variable.name;
                              call scs$ioa←nnl("↑a&lt;-↑8w, ",
                                   substr(vp->string.text,1,vp->string.length),
                                   fp->variable.value);
                              end;
                         else call scs$ioa←nnl("↑i(↑a), ",
                              offset,reg←names(base←reg));
                    end;
          end;
     call scs$ioa;
     return;

end;
↑L 
     Listing of >s>langs>sine>buffer.pl1     12/30/79 17:27:40

pl1←make←buffer:    proc(buf,buf←ptr);

%include address←space;
%include data←types;

 dcl buf ptr;
 dcl buf←ptr ptr;

 dcl hcs$append←seg entry (char(168)varying,char(32)varying,fixed(31));
 dcl hcs$truncate←file entry(char(168)vary,char(32)vary,fixed,fixed(31));
 dcl hcs$initiate entry(char(168)vary,char(32)vary,ptr,fixed(31));
 dcl scs$get←uname entry returns(char(8)varying);
 dcl scs$break←entry entry;
 dcl com←error entry options(variable);
 dcl $swapify entry (ptr);
 dcl $pl1←allocate entry (fixed(31),ptr);

 dcl dname char(168)varying static init(">process←dir>sine←segments");
 dcl ename char(32) varying;
 dcl code fixed(31);
 dcl uname char(8) varying;
 dcl null←name char(32) varying static init("");
 dcl bp ptr;
 dcl tp ptr;

 dcl size builtin;

 dcl 1 bufname←suffix unaligned static,
          2 fixed←part char(13) init(".sine←buffer."),
          2 varying←part fixed bin(7) init(96);
 dcl suffix char(14) defined bufname←suffix;
 dcl suffix←char char(1) defined varying←part;

     call $pl1←allocate(size(buffer),bp);
/* allocate buffer in(string←space) set(bp); */
     bp->buffer.next = null();
     bp->buffer.real←hole = null();
     bp->buffer.location = 0;
     bp->buffer.gap←start = 0;
     bp->buffer.gap←end = 500;
     bp->buffer.top = 500;
     bp->buffer.start←mod = null();
     bp->buffer.end←mod = null();
     bp->buffer.marker←chain = null();
     bp->buffer.flags = "0"b;
     unspec(buf) = unspec(bp) | "10000000"b4;

     if buf←ptr = null()
          then do;
               uname = scs$get←uname ();
               varying←part = varying←part + 1;
               ename = uname || suffix;
               bp->buffer.file←suffix = suffix←char;
               call hcs$append←seg (dname,ename,code);
               call hcs$truncate←file (dname,ename,0,code);
               call hcs$initiate(dname,ename,tp,code);
               if code &lt; 0 then do;  /* address←space full (?) */
                    call com←error(code,"make←buffer");
                    call scs$break←entry;
                    return;
                    end;
               end;
          else do;
               bp->buffer.file←suffix = "\@";
               tp = buf←ptr;
               end;
     bp->buffer.base = tp;
     call $swapify(bp);
     return;

end;
↑L 
     Listing of >s>langs>sine>swap←in.pl1    12/30/79 17:27:33

incorify:  proc(buf);

%include data←types;

dcl buf pointer;

dcl init←hack (20) fixed(31) static init((20)0);
dcl 1 seg←table(10) defined init←hack,
     2 buf ptr,
     2 time fixed(31);
dcl num←segs fixed static init(0);
dcl time fixed(31) static init(0);
dcl max←segs fixed static init(0);
dcl max←swapable←segs fixed static init(3);

dcl scs$ioa entry options(variable);
dcl scs$break←entry entry;

dcl tp pointer;
dcl last←free fixed;
dcl i fixed;
dcl arn bit(1) init("1"b);

     if buf->buffer.base ↑= ptr(2,-2) then return;
     do while (num←segs >= max←swapable←segs);
          call best←seg←to←punt(i);
          call swap←out(i);
          arn = "0"b;
          end;
     if arn then do;
          do i = 1 to max←segs;
               if seg←table(i).buf = null() then go to found←slot;
               end;
          max←segs = max←segs + 1;
          i = max←segs;
          end;
found←slot:
     call swap←in(buf,i,arn);
/*
call scs$ioa("Incorifying ↑p",buf);
do i = 1 to max←segs;
call scs$ioa("↑i ↑p@↑p",i,seg←table(i).buf,seg←table(i).buf->buffer.base);
end;
*/

     return;

swapify:       entry(buf);
     /* makes the buffer known to the swaping data base (swl) */

     if num←segs >= max←swapable←segs
          then do;
               call best←seg←to←punt(i);
               call swap←out(i);
               end;
          else do;
               do i = 1 to max←segs;
                    if seg←table(i).buf = null() then go to got←slot;
                    end;
               max←segs = max←segs + 1;
               i = max←segs;
               end;
got←slot:
     if seg←table(i).buf ↑= null() then do;
          call scs$ioa("Swapout failed!?!?! (↑i) ↑p@↑p still here",i,
               seg←table(i).buf,seg←table(i).buf->buffer.base);
          call scs$break←entry;
          end;
     seg←table(i).buf = buf;
     time = time + 1;
     seg←table(i).time = time;
     num←segs = num←segs + 1;
/*
call scs$ioa("Swapifing ↑p@↑p",buf,buf->buffer.base);
do i = 1 to max←segs;
call scs$ioa("↑i ↑p@↑p",i,seg←table(i).buf,seg←table(i).buf->buffer.base);
end;
*/
     return;

best←seg←to←punt:   proc(best←seg);

dcl best←seg fixed;
dcl best←time fixed(31);
dcl i fixed;

     best←time = 30000;
     best←seg = 0;
     do i = 1 to max←segs;
          if seg←table(i).buf = null() then continue;
          if substr(seg←table(i).buf->buffer.flags,2,1) then continue;
          if seg←table(i).time &lt; best←time then do;
               best←time = seg←table(i).time;
               best←seg = i;
               end;
          end;
     if best←seg = 0 then do;
          call scs$ioa("COD@5: no paddle↑runder consideration:");
          do i = 1 to max←segs;
               call scs$ioa ("↑i: ↑8w (time=↑i)",
                    i,seg←table(i).buf,seg←table(i).time);
               end;
          call scs$break←entry;
          end;
     return;
     end;

swap←out: proc(e);

%include address←space;

 dcl e fixed;
 dcl buf ptr;
 dcl four fixed(31) init(4);
 dcl swap←segs$out entry (ptr,ptr);
 dcl scs$nothing ptr external;
 dcl hcs$switch←call entry (char(4),ptr,ptr,ptr);

 dcl current←space char(4) aligned static init("sina");
 dcl current←space←number fixed(31) defined current←space;
 dcl space←ptr ptr static init(null());
 dcl seg←no fixed static init(2);
 dcl i fixed;

     buf = seg←table(e).buf;
     if buf->buffer.base = ptr(2,-2) then do;     /* already swapped out */
          call scs$ioa("Already swapped out! (↑i) ↑p@↑p",e,buf,buf->buffer.base);
          call scs$break←entry;
          return;
          end;
     if buf->buffer.real←hole = null() then do;
find←a←free←segment:
          if space←ptr = null()
               then do;
                         /* make sure the space exists */
                    call hcs$switch←call(current←space,addr(scs$nothing),
                         addr(four),null());
                    do space←ptr = ptr(13,"00cc"b4) repeat space←ptr->as.next
                       while (space←ptr->as.name ↑= current←space);
                         end;
                    end;
          do i = seg←no to 12;
               if space←ptr->as.sdbs(i).sdbofs = "0"b then do;
                    buf->buffer.real←hole = ptr(i,rel(space←ptr));
                    seg←no = i + 1;
                    go to outen←it;
                    end;
               end;
          current←space←number = current←space←number + 1;
          space←ptr = null();
          seg←no = 2;
          go to find←a←free←segment;
          end;

outen←it:
     call swap←segs$out(buf->buffer.base,buf->buffer.real←hole);
/*
call scs$ioa ("swapped out buffer ↑p from ↑p",buf,buf->buffer.base);
*/
     buf->buffer.base = ptr(2,-2); /* mark it as not here */
     seg←table(e).buf = null();
     num←segs = num←segs - 1;
     return;

     end;

swap←in:  proc(buf,e,arn);

%include tcb;

dcl buf ptr;
dcl e fixed;
dcl arn bit(1);
dcl tp ptr;
dcl scs$break←entry entry;
dcl i fixed;
dcl swap←segs$in entry (ptr,ptr);
dcl hcs$cur←task ptr external;
dcl asp ptr;
dcl 1 addr←s based(asp),      /* the current address space */
     2 next ptr,
     2 sdb (0:16) bit(32);
dcl hcs$add←ref←name entry(ptr,char(32)varying);

dcl 1 ref←hack static unaligned,
     2 len fixed(31) init(16),
     2 string←part←1 char(15) init("sine←swap←segs."),
     2 index char(1) init("a");
dcl refname char(32)varying defined ref←hack;
dcl ref←index fixed bin(7) defined ref←hack.index;

     if buf->buffer.base ↑= ptr(2,-2) then return;
     if buf->buffer.real←hole = null() then do;
          call scs$ioa("No place to swap buffer: ↑p",buf);
          call scs$break←entry;
          return;
          end;

     asp = hcs$cur←task->tcb.address←space←ptr;
     do i = 3 to 12;
          if sdb(i) = "0"b then do;
               tp = ptr(i,0);
               call swap←segs$in(buf->buffer.real←hole,tp);
               buf->buffer.base = tp;
               seg←table(e).buf = buf;
               time = time + 1;
               seg←table(e).time = time;
               num←segs = num←segs + 1;
               if arn then call hcs$add←ref←name (tp,refname);
               ref←index = ref←index + 1;
/*
call scs$ioa ("swapped in buffer ↑p to ↑p @ ↑i",seg←table(e).buf,tp,time);
*/
               return;
               end;
          end;

     call scs$ioa("No free segments in AS");
     call scs$break←entry;
     end;

     return;

gc←swap←in←table:   entry (table←ptr);

dcl table←ptr ptr options(nomap);

     table←ptr = addr(init←hack(1));
     return;

end;
↑L 
     Listing of >s>langs>sine>clean←sine.pl1 12/30/79 17:27:11

clean←sine: proc;
cs:entry;

dcl hcs$terminate←in←space entry (ptr,char(4),fixed(31));
dcl i fixed;
dcl code fixed(31);
dcl space char(4) init("↑@↑@↑@↑A");
dcl lp ptr init(ptr(14,96));
dcl 1 link based(lp),
     2 b1 bit(16),
     2 b2 bit(16),
     2 b3 bit(16),
     2 l1 fixed,
     2 l2 fixed,
     2 name char(7);
dcl scs$ioa entry options(variable);
dcl scs$get←arg←info entry (fixed,fixed,fixed,ptr);
dcl ap ptr;
dcl al fixed;
dcl arg char(al) based(ap);

call scs$get←arg←info(1,i,al,ap);
if ap ↑= null() then space = arg;

do i = 3 to 12;
     call hcs$terminate←in←space(ptr(i,0),space,code);
     end;
if name = "pb$plod"
     then do;
          b1 = "e100"b4;
          b2 = "4000"b4;
          b3 = "0000"b4;
          end;
     else call scs$ioa("link to pb$plod moved??");

end;
↑L 
     Listing of >s>langs>sine>sfd.pl1   12/30/79 17:27:01

sfd: proc(screen);  /* Scan For Damage (to the screen) */

dcl 1 screen,
     2 next ptr,
     2 buffer←ptr ptr,
     2 real←posn fixed,
     2 last←line fixed,
     2 first←mod fixed,
     2 displayed fixed,
     2 current←line fixed,
     2 pad fixed,
     2 force←display bit(32),
     2 emptyp bit(32),
     2 last←top ptr,
     2 line←points (1) ptr;

dcl bufp ptr;
dcl 1 buffer based(bufp),
     2 next ptr,
     2 base ptr,
     2 real←hole bit(32),
     2 location fixed(31),
     2 gap←start fixed(31),
     2 gap←end fixed(31),
     2 top fixed(31),
     2 start←mod ptr,
     2 end←mod ptr;

dcl 1 line←def based unaligned,
     2 start ptr,
     2 end ptr,
     2 empty bit(1),
     2 pad char(3);

dcl 1 line like line←def;
dcl $get←line entry (ptr,ptr,bit(1),structure);
dcl $backup entry (ptr,ptr,fixed,bit(1));

dcl 1 old←screen,
     2 num←lines fixed,
     2 lines (25) like line←def;

dcl 1 new←screen,
     2 num←lines fixed,
     2 lines (25) like line←def;

dcl (where←start←mod, where←end←mod, where←point, where←first←line) ptr;
dcl (where←end,where←top) ptr;
dcl (current←place,starting←place) ptr;
dcl prefered←line fixed (31);
dcl (length←of←screen,point←line,old←point←line,lines←to←get,lines←got,
     bottom←line,start←mod←line,end←mod←line) fixed;
dcl new←point←line fixed;
dcl i fixed;
dcl (tob,bob) bit(1);

     bufp = screen.buffer←ptr;
     length←of←screen = screen.last←line/4;
     i = buffer.top;
     if buffer.gap←end = i then i = buffer.gap←start;
     where←end = addrel(buffer.base,i);
     call extract←old←screen(screen,old←screen);
     where←top = addrel(buffer.base,buffer.top);
     where←start←mod = unmarkify(buffer.start←mod,buffer);
     where←end←mod = unmarkify(buffer.end←mod,buffer);
     where←point = abs(bufp->buffer.location,buffer);
     where←first←line = unmarkify(screen.line←points(1),buffer);
     unspec(prefered←line) = screen.force←display;
     old←point←line = which←line(old←screen,where←point,"1"b);
     screen.first←mod = -1;
     screen.force←display = "0"b;

     if prefered←line &lt; 0 then do;
center:   new←point←line = length←of←screen/2+1;
          go to start←backup;
          end;
     else if prefered←line > 0 then do;
          new←point←line = prefered←line+1;
          go to start←backup;
          end;
     else if old←point←line > length←of←screen then go to center;
     else if (where←start←mod &lt; where←first←line &
              where←end←mod > where←first←line) then do;
          new←point←line = old←point←line+1;
          go to start←backup;
          end;
     else if (((where←end←mod = where←first←line) &
              (where←start←mod &lt;= where←end←mod)) &
              (rel(where←start←mod) &lt; rel(screen.last←top)))
          then do;
               go to center;
start←backup:
/*
     If the area of modification includes the beginning of the screen
     then we are unsure as to where the top of the screen is.  Also if the
     optimal centering of the screen is desired then the top of the screen
     is unknown.  The following code finds it by backing up a
     distance that is sure to be far enough and going forward until
     we get to a line containing point.  Then we backup until we get
     to the top of the screen.

     If the prefered←line indicates a recentering or if a line is specified
     and the old screen didn't contain all the info then we also need
     to find the top of the screen.  The case of prefered←line &lt;=
     old←point←line can be optimize by just copying info out of the
     old screen but it isn't worth it here.

     If the current←point has fallen off the bottom of the screen we
     must also recenter ourselves.
*/

               call $backup(bufp,starting←place,new←point←line,tob);
/*
dcl scs$ioa←nnl entry options(variable);
call scs$ioa←nnl("↑40:23oxybackup: ↑p, ↑i lines, ↑2w",starting←place,
     new←point←line,tob);
call scs$ioa←nnl("↑20:24oxystart: ↑p, end: ↑p, first: ↑4w, top: ↑4w",
     where←start←mod,where←end←mod,rel(where←first←line),rel(screen.last←top));
call scs$ioa←nnl("↑1:24oxypt: ↑p, opl: ↑i",where←point,old←point←line);
*/

               call stack$flush;
               current←place = starting←place;
find←point:    call $get←line (buffer←ptr,current←place,bob,line);
               if ↑line.empty then do;
                    call stack$push(line);
                    if ↑inlinep(where←point,line) then go to find←point;
                    end;
               point←line = stack$count();   /* save line number of point */
               if point←line &lt;= new←point←line
                    then new←point←line = point←line + 1;

/*
     Now we have to select the correct place to put the point←line on the
     screen.  There are two steps to this: first to decide how many lines
     after point we would like to fill up the screen, and second deciding
     where to start filling in the lines that we pop off the stack.

     The procedure for finding the optimal placing for the point←line
     depends on whether the guy has a preference or not.  If he has a
     specific line in mind then we would like to fill from the prefered
     line to the end with lines after point.  If he said "recenter" or
     if we don't know where old←point←line was then try and fill as much
     of the screen as possible.  If there were not modifications above
     point then we can minimize the amount of redisplay by leaving the
     point←line where it was.
*/
/*
               if prefered←line > 0
                    then lines←to←get = length←of←screen - prefered←line;
                    else if where←end←mod &lt;= where←point & prefered←line = 0
                              & old←point←line &lt;= length←of←screen
                              & screen.last←top = where←first←line
                         then lines←to←get = length←of←screen - 
                              old←point←line;
                         else do;
                              lines←to←get = max (length←of←screen-point←line,
                                   length←of←screen/2);
                              if prefered←line = 0 then prefered←line = -2;
                              end;
*/

               lines←to←get = length←of←screen - new←point←line + 1;
               do i = 1 to lines←to←get while(bob = "0"b);
                    call $get←line (buffer←ptr,current←place,bob,line);
                    call stack$push (line);
                    end;
               lines←got = stack$count() - point←line;

/*
     Now we are all set and just have to fill in the new screen with
     the lines we've found.  If the stack empties it will return "blank"
     lines.  If there weren't enough lines to fill the bottom part of the
     screen then if the point←line is fixed just fill with blanks else
     try and split up the "extra" lines between the top part and the bottom
     part.
*/
/*
               if prefered←line &lt; 0
                    then if prefered←line = -2 & lines←got = 0
                              then bottom←line = (length←of←screen+1)/2;
                              else bottom←line = length←of←screen -
                                   (lines←to←get-lines←got)/2;
                    else if prefered←line = 0
                         then bottom←line = length←of←screen -
                              (lines←to←get - lines←got);
                         else bottom←line = prefered←line + lines←got;
*/
               bottom←line = new←point←line + lines←got - 1;
               do i = bottom←line+1 to length←of←screen;
                    call line$empty(new←screen.lines(i));
                    end;
               do i = bottom←line to 1 by -1;
                    call stack$pop(new←screen.lines(i));
                    end;
               old←point←line = bottom←line - lines←got;
               end;
          else do;
/*
     In this case the modifications to the buffer (if any) are after the
     point so we should leave it where it is to minimize redisplay.  Thus
     we copy the old←screen's info info the new screen until we get to
     a line containing where←start←mod or the end of the screen.  If we
     encounter modifications we just start consing up new lines.
*/
               if where←start←mod > where←end←mod then go to punt;
               start←mod←line = which←line(old←screen,where←start←mod,"1"b);
               if where←start←mod = old←screen.lines(start←mod←line).start
                    then start←mod←line = start←mod←line -1;
               if start←mod←line = 0 then start←mod←line = 1;
               do i = 1 to start←mod←line - 1;
                    call line$assign(new←screen.lines(i),old←screen.lines(i));
                    end;
               if start←mod←line &lt;= length←of←screen then do;
                    current←place = old←screen.lines(start←mod←line).start;
                    end←mod←line = which←line(old←screen,where←end←mod,"1"b);
                    do i = start←mod←line to length←of←screen;
                         call $get←line(buffer←ptr,current←place,bob,line);
                         call line$assign(new←screen.lines(i),line);
                         if i > end←mod←line &
                            line$equal(line,old←screen.lines(i)) then do;
                              do i = i+1 to length←of←screen;
                                   call line$assign(new←screen.lines(i),
                                        old←screen.lines(i));
                                   end;
                              leave;
                              end;
                         end;
                    old←point←line = which←line(new←screen,where←point,"0"b);
                    if old←point←line > length←of←screen then go to center;
                    end;
               end;
/*
     All that is left is to decide which lines should be printed.
*/
     start←mod←line = which←line(new←screen,where←start←mod,"1"b);
     end←mod←line = which←line(new←screen,where←end←mod,"1"b);
     if prefered←line = -1    /* the screen is garbage redisp everything */
          then do;
               screen.force←display = "ffffffff"b4;
               do i = 1 to length←of←screen;
                    call line$assign(old←screen.lines(i), new←screen.lines(i));
                    end;
               end;
          else do;
               do i = 1 to length←of←screen;
                    if ↑line$equal(new←screen.lines(i),old←screen.lines(i))
                         then do;
                              call line$assign(old←screen.lines(i),
                                   new←screen.lines(i));
                              substr(screen.force←display,i,1) = "1"b;
                              end;
                    end;
               if ↑substr(screen.force←display,start←mod←line-1,1)
                  | start←mod←line = 1 then if where←start←mod &lt;= where←end←mod
                    then screen.first←mod = start←mod←line*4-4;
               do i = start←mod←line to end←mod←line;  /* anything modified */
                    substr(screen.force←display,i,1) = "1"b;
                    end;
               end;

punt:
     call insert←new←screen(screen,old←screen);
     if old←point←line = 0 then old←point←line = 1;
     screen.current←line = old←point←line*4 - 4;
     screen.last←top = where←first←line;
     return;

buffer←stuff:proc returns(char(1));

dcl 1 buf like buffer;
dcl place ptr;
dcl (bob,tob) bit(1);
dcl char char(1);
dcl bchar char(1) based(place);

buffer$get←next←char: entry (buf,place,bob) returns(char(1));

     if place = addrel(buf.base,buf.gap←start)
          then place = addrel(buf.base,buf.gap←end);
     if place >= addrel(buf.base,buf.top)
          then do;
               bob = "1"b;
               return ("X");
               end;
          else bob = "0"b;
     char = bchar;
     place = addrel (place,1);
     return (char);

buffer$get←previous←char: entry (buf,place,tob) returns(char(1));

     if place = addrel(buf.base,buf.gap←end)
          then place = addrel(buf.base,buf.gap←start);
     if place &lt;= buf.base
          then do;
               tob = "1"b;
               return ("X");
               end;
     tob = "0"b;
     place = addrel(place,-1);
     return (bchar);

     end; /* buffer stuff */


dcl 1 l like line←def;
dcl 1 stack based(tos),
     2 prev ptr,
     2 l like line←def;
dcl tos ptr static init(null());
dcl tp ptr;
dcl cnt fixed;

stack$flush:proc;

     do tos = tos repeat tp while (tos ↑= null());
          tp = stack.prev;
          free stack;
          end;
     cnt = 0;
     end;

stack$push: proc(line);
dcl 1 line like line←def;

     tp = tos;
     allocate stack;
     prev = tp;
     cnt = cnt + 1;
     stack.l = line;
/*   call line$assign(stack.l,line); */

     return;
     end;

stack$pop: proc (line);
dcl 1 line like line←def;
     if tos = null() then do;
          call line$empty(line);
          return;
          end;
     tp = prev;
     line = stack.l;
/*   call line$assign(line, stack.l); */

     free stack;
     tos = tp;
     end;

stack$count: proc returns (fixed);
     return (cnt);
     end;
/*
get←line: proc(place,bob,line);
dcl place ptr;
dcl bob bit(1);
dcl 1 line like line←def;
dcl char char(1);
dcl i fixed init(0);
dcl bchar char(1) based(place);

     line.start = place;
     if place = addrel(buffer.base,buffer.gap←start)
          then place = addrel(buffer.base,buffer.gap←end);
     if place >= where←top
          then do;
               line.empty = "1"b;
               bob = "1"b;
               return;
               end;
     bob = "0"b;
     char = bchar;
     place = addrel (place,1);

get←char←loop:
     if char = "\m" then go to got←a←line;
     if place = addrel(buffer.base,buffer.gap←start)
          then place = addrel(buffer.base,buffer.gap←end);
     if place &lt; where←top
          then do;
               char = bchar;
               place = addrel (place,1);
               go to get←char←loop;
               end;
          else bob = "1"b;

got←a←line:
     line.end = place;
     line.empty = "0"b;
     return;
     end;
*/

which←line:proc(ls,place,last←line) returns (fixed);

dcl 1 ls like new←screen;
dcl place ptr;
dcl last←line bit(1);

dcl i fixed;
dcl before bit(1) init("0"b);
dcl (b,e) ptr;
dcl where←i←am ptr;

     where←i←am = place;
     if where←i←am &lt; ls.lines(1).start then return (length←of←screen+1);
     do i = 1 to length←of←screen;
          if ls.lines(i).empty
               then if before
                    then return(i-1);
                    else continue;
               else before = "1"b;
          b = ls.lines(i).start;
          e = ls.lines(i).end;
          if where←i←am = b then if b = e then go to ret;
          if where←i←am >= b then if where←i←am &lt; e then go to ret;
          end;
     if last←line then
          if where←i←am=e then if e=where←end then return(length←of←screen);
ret:
     return (i);
     end; /* which line */

line$assign:proc(line1,line2);

dcl 1 line1 like line←def;
dcl 1 line2 like line←def;

     line1 = line2;
/*
     line1.start = line2.start;
     line1.end = line2.end;
     line1.empty = line2.empty;
*/
     end;

line$equal:    proc(line1,line2) returns(bit(1));
dcl 1 line1 like line←def;
dcl 1 line2 like line←def;

     if line1.empty then if line2.empty then return ("1"b);
                                        else return ("0"b);
                    else if line2.empty then return ("0"b);
     if line1.start = line2.start then if line1.end = line2.end
          then return ("1"b);
     return("0"b);
     end;

line$emptyp:proc(line) returns(bit(1));
dcl 1 line like line←def;
     return(line.empty);
end;

line$empty:proc (line);

dcl 1 line like line←def;

     line.empty = "1"b;
     return;
     end;

line$start:proc(line) returns(ptr);

dcl 1 line like line←def;

     if line.empty
          then return(null());
          else return(line.start);
     end;

line$end:proc(line) returns(ptr);

dcl 1 line like line←def;

     if line.empty
          then return(null());
          else return(line.end);
     end;

inlinep:  proc(place,line) returns(bit(1));
dcl place ptr;
dcl 1 line like line←def;

     if line.empty then return("0"b);
     if place >= line.start then if place &lt; line.end
          then return ("1"b);
     return ("0"b);
     end;

unmarkify:     proc(mark←ptr,buf) returns(ptr);

dcl mark←ptr ptr;
dcl 1 buf like buffer;
dcl 1 mark based(mark←ptr),
     2 next ptr,
     2 top←part bit(16),
     2 abs←offset bit(16);
dcl tp ptr;

     tp = addrel(buf.base,abs←offset);
     if tp = addrel(buf.base,buf.gap←end)
          then tp = addrel(buf.base,buf.gap←start);
     return (tp);

markify:  entry(mark←ptr,place);
dcl place ptr;
     mark←ptr->mark.abs←offset = unspec(rel(place));
/*   if abs←offset = buffer.gap←start then abs←offset = buffer.gap←end;*/
     return;

     end;

abs: proc(offset,buf) returns(ptr);

dcl offset fixed(31);
dcl 1 buf like buffer;
dcl i fixed(31);
     i = offset;
     if buf.gap←start &lt; i then i = i + buf.gap←end-buf.gap←start;
     return (addrel(buf.base,i));
     end;

max: proc(a,b) returns(fixed);
dcl (a,b) fixed;
if a > b
     then return (a);
     else return (b);
end;

extract←old←screen:proc(source,object);
dcl 1 source like screen;
dcl 1 object like old←screen;
dcl ll ptr;
dcl lll ptr;

     object.num←lines = length←of←screen;
     ll = unmarkify(source.line←points(1),buffer);
     do i = 1 to length←of←screen;
          object.lines(i).start = ll;
          lll = unmarkify(source.line←points(i+1),buffer);
          object.lines(i).end = lll;
          object.lines(i).empty = substr(source.emptyp,i,1);
/*
          if rel(ll) = 0 then if rel(lll) = 0 then object.lines(i).empty="1"b;
          if ll = where←end then if lll = where←end
               then object.lines(i).empty="1"b;
*/
          ll = lll;
          end;
end;

insert←new←screen:proc(source,object);
dcl 1 source like screen;
dcl 1 object like new←screen;
dcl j fixed;
dcl all←empty bit(1) init("1"b);

     do i = 1 to length←of←screen;
          substr(source.emptyp,i,1) = object.lines(i).empty;
          end;
     do i = 1 to length←of←screen;
          if ↑object.lines(i).empty then do;
               all←empty = "0"b;
               tp = object.lines(i).start;
               do j = 1 to i;
                    call markify(source.line←points(j),tp);
                    end;
               do i = i+1 to length←of←screen;
                    if object.lines(i).empty then do;
                         tp = object.lines(i-1).end;
                         call markify(source.line←points(i),tp);
                         if rel(tp) = buffer.gap←start
                              then rel(tp) = buffer.gap←end;
                         do j = i+1 to length←of←screen+1;
                              call markify(source.line←points(j),tp);
                              end;
                         return;
                         end;
                    call markify(source.line←points(i),
                                 object.lines(i).start);
                    end;
               call markify(source.line←points(length←of←screen+1),
                            object.lines(length←of←screen).end);
               return;
               end;
          end;

     if all←empty then do;
          tp = buffer.base;
          do i = 1 to length←of←screen+1;
               call markify(source.line←points(i),tp);
               if i = old←point←line then tp = addrel(tp,buffer.top);
               end;
          end;

     return;

end; /* insert←new←screen */

end;

↑L 
     Listing of >s>langs>sine>sine←gc.pl1    12/30/79 17:26:49

sine←gc:  proc (state,toh,variable←chain,current←screen←ptr,screen←chain,
                lines,arglist,restart);

dcl toh ptr options (nomap);  /* top of heap: where to allocate new storage */
dcl variable←chain ptr options (nomap); /* links all vbls together */
dcl current←screen←ptr ptr options(nomap);
dcl screen←chain ptr options(nomap);
dcl 1 lines,
          2 screen (25) ptr;
dcl 1 arglist,
          2 args (4) ptr;
dcl 1 restart,
          2 buf ptr,
          2 loc fixed(31),
          2 vbl←tab ptr;
dcl 1 seg←table (10) based (table←ptr),
          2 buf ptr,
          2 foo bit(32);

%include state;
%include stack;
%include data←types;

/*   This is a stand alone copying garbage collector for the sine machine.
     It knows the location of the sine←string←space which is the heap to
     be GC'ed and the sine←stack which contains most of the references to
     objects that must not be GC'ed.  It is passed as arguments all the other
     relavent info.  It is designed to run in a separate address space thus
     its stand alone ish ness.                                             */

dcl hcs$initiate←w←options entry (char(168)vary, char(32)vary, char(32)vary,
     bit(1), ptr, fixed(31));
dcl hcs$append←seg entry (char(168)vary, char(32)vary, fixed(31));
dcl hcs$truncate←file entry (char(168) vary, char(32)vary, fixed, fixed(31));
dcl scs$get←uname entry returns(char(8)vary);
dcl scs$find←gate←space entry (char(32)vary,char(4),char(4),ptr,fixed(31));
dcl com←error entry options(variable);
dcl scs$ioa entry options(variable);
dcl sine←machine$gc←swap←in←table entry returns(ptr);

dcl size builtin;
dcl gcbug condition;

dcl uname char(8) varying;
dcl dir char(168)varying static init (">process←dir>sine←segments");
dcl string←space←name char(32)varying static;
dcl string←space←ptr ptr static;
dcl stack←name char(32)varying static;
dcl heap char(1) based (string←space←ptr);
dcl new←string←space←name char(32)vary static;
dcl new←string←space←ptr ptr static;
dcl table←ptr ptr static;
dcl 1 gc←temp based(new←string←space←ptr),
          2 new←heap char(1);
dcl new←toh ptr;
dcl top ptr;
dcl tp ptr;
dcl ftp fixed(31) defined tp;
dcl sb ptr;
dcl bp ptr based;
dcl forward bit(32) based;
dcl code fixed(31);
dcl nspace char(4);
dcl new←segno fixed static;
dcl segno fixed static;
dcl off fixed;
dcl num fixed;
dcl i fixed;

dcl first←time bit(1) static init("1"b);
dcl debug bit(1) init("1"b);

dcl metering←data←num(11) static init ((11) 0);
dcl metering←data←size(11) static init ((11)0);
dcl number←of←gcs fixed static init (0);

     if first←time then do;
          uname = scs$get←uname();
          string←space←name = uname || ".sine←string←space";
          call scs$find←gate←space(string←space←name,"    ",nspace,
               string←space←ptr,code);
          if code &lt; 0 then do;
barf←out:      call com←error (code,"sine←gc");
               signal gcbug;
               return;
               end;
          call hcs$initiate←w←options (dir,string←space←name,string←space←name,
               "1"b,string←space←ptr,code);
          if code &lt; 0 then go to barf←out;
          segno = baseno(string←space←ptr);
          stack←name = uname || ".sine←stack";
          call scs$find←gate←space(stack←name,nspace,nspace,tp,code);
          if code &lt; 0 then go to barf←out;
          call hcs$initiate←w←options (dir, stack←name, "sine←stack",
               "1"b,tp,code);
          if code &lt; 0 then go to barf←out;
          new←string←space←name = uname || ".sine←new←string←space";
          call hcs$append←seg (dir,new←string←space←name,code);
          call hcs$initiate←w←options (dir,new←string←space←name,
               new←string←space←name, "0"b, new←string←space←ptr, code);
          if code &lt; 0 then go to barf←out;
          new←segno = baseno(new←string←space←ptr);
          table←ptr = sine←machine$gc←swap←in←table();
          first←time = "0"b;
          end;

     call hcs$truncate←file (dir,new←string←space←name,0,code);
     if code &lt; 0 then go to barf←out;
     call hcs$truncate←file (dir,stack←name,rel(state.sp)/2048+1,code);

     number←of←gcs = number←of←gcs + 1;
     new←toh = new←string←space←ptr;

/*   We start by getting everything on the stack  */

     top = state.sp;
     do sb = state.sb repeat frame.saved←sb while (sb ↑= null());
          call gc (frame.saved←pc.buf);
          call gc (frame.saved←ip);
          call gc (frame.name←of←function);
          do tp = frame.handlers repeat tp->handlers.next while (tp ↑= null());
               call gc (tp->handlers.addr←buf);
               end;
          num = frame.num←temps;
          tp = addr(frame.temps(0));
          do i = 1 to num;
               call gc (tp->bp);
               ftp = ftp + 4;
               end;
          num = frame.num←bound;
          do i = 1 to num;
               off = rel(tp->bindings.value←addr)-rel(tp->bindings.object);
               call gc (tp->bindings.object);
               call gc (tp->bindings.old←value);
               rel(tp->bindings.value←addr) = rel(tp->bindings.object) +
                    off;
               ftp = ftp + 12;
               end;
          if frame.handlers ↑= null()             /* last handler */
               then tp = addrel(frame.handlers,size(handlers));
          do ftp = ftp repeat ftp + 4 while (tp &lt; top);
               call gc (tp->bp);
               end;
          top = sb;
          end;

/* Now we get all the variables */

     call gc (variable←chain);
     call gc (state.pc.buf);
     call gc (state.ip);
     call gc (current←screen←ptr);
     call gc (screen←chain);
     do i = 1 to 25;
          call gc (lines.screen(i));
          end;
     do i = 1 to 4;
          call gc (arglist.args(i));
          end;
     call gc (restart.buf);
     call gc (restart.vbl←tab);
     do i = 1 to 10;
          tp = seg←table(i).buf;
          if tp ↑= null() then unspec(tp) = unspec(tp) | "10000000"b4;
          call gc (tp);
          seg←table(i).buf = tp;
          end;

/* All done except for cleanup */

     call hcs$truncate←file (dir,string←space←name,rel(new←toh)/2048+1,code);
     if code &lt; 0 then go to barf←out;
     code = rel(new←toh);
     substr(heap,1,code) = substr(new←heap,1,code);
     rel(toh) = code;

     return;

gc:  proc(aobject);

dcl aobject ptr;
dcl object←base ptr;
dcl object ptr based(object←base);
dcl nobject ptr;
dcl tp ptr;
dcl fp ptr;
dcl 1 overlays based(object←base) unaligned,
     2 type bit(4),
     2 seg←in fixed bin (7);

dcl data←type fixed;
dcl i fixed;
dcl num fixed;
dcl types (14) label constant;
dcl forward bit(32) based (object);
dcl vbls (0:1) ptr based;
dcl bnum fixed(31) based;
dcl bchar char(1) based;

     object←base = addr(aobject);
loop←dont←recurse:
     data←type = type;
     if data←type = 0 then return;      /* numbers... */
     if data←type = 15 then return;
     if segno ↑= seg←in then return;
     if (forward & "fff00000"b4) = "fab00000"b4 then do;
          unspec(object) =
               (unspec(object)&"f0000000"b4) | (forward&"000fffff"b4);
          return;
          end;
     go to types(data←type);

types(*):
     signal gcbug;

types(1):      /* buffer */
     call copy (size(buffer));
     call gc (nobject->buffer.marker←chain);
     call gc (nobject->buffer.start←mod);
     call gc (nobject->buffer.end←mod);
     return;

types(2):      /* string */
     call copy ((object->string.length+2)/4*4+4);
     return;

types(3):      /* window */
     call copy (size(window));
     call gc (nobject->window.real←text);
     call gc (nobject->window.start);
     call gc (nobject->window.stop);
     return;

types(4):      /* cons */
     call copy (size(cons));
     call gc (nobject->cons.car);
/*   call gc (nobject->cons.cdr); */
     object←base = addr(nobject->cons.cdr);
     go to loop←dont←recurse;
     return;

types(5):      /* variable */
     call copy (size(variable));
     call gc (nobject->variable.name);
     call gc (nobject->variable.value);
/*   call gc (nobject->variable.next); */
     object←base = addr(nobject->variable.next);
     go to loop←dont←recurse;
     return;

types(6):      /* function */
     call copy (size(function));
     call gc (nobject->function.buf);
     call gc (nobject->function.vbl←tab);
     return;

types(7):      /* marker */
     call copy (size(marker));
/*   call gc (nobject->marker.next); */
     object←base = addr(nobject->marker.next);
     go to loop←dont←recurse;
     return;

types(8):      /* screen */
     call copy (size(screen));
     call gc (nobject->screen.buffer);
     do i = 1 to 25;
          call gc (nobject->screen.start(i));
          end;
/*   call gc (nobject->screen.next); */
     object←base = addr(nobject->screen.next);
     go to loop←dont←recurse;
     return;

types(9):      /* array */
     num = object->array.size;
     i = size(array)+object->array.type*num/8;
     call copy (i);
     if nobject->array.type = 32 then do i = 1 to num;
          call gc (nobject->array.cells(i));
          end;
     return;

types(10):     /* gnirt */
     tp = object;             /* for efficiency */
     tp->gnirt.max←length = tp->gnirt.real←length/16*16+16;
     call copy (size(gnirt));
     tp = object;             /* save the new object */
     object = nobject->gnirt.real←text;
     fp = nobject;            /* save its real place */
     call copy (nobject->gnirt.max←length);
     fp->gnirt.real←text = object;
     object = tp;
     return;

types(11):     /* vbl←tab */
     call copy (object->vbl←tab.num*4+4);
     do i = 1 to nobject->vbl←tab.num;
          call gc (nobject->vbl←tab.vbls(i));
          end;
     return;

copy:     proc (bytes);

dcl bytes fixed;
dcl old←object ptr;
dcl forward bit(32) based (object);

     metering←data←num(data←type) = metering←data←num(data←type) + 1;
     metering←data←size(data←type) = metering←data←size(data←type) + bytes;

     old←object = object;
     substr(new←toh->new←heap,1,bytes) = substr(old←object->heap,1,bytes);
     rel(object) = rel(new←toh);
     new←toh = addrel(new←toh,bytes);
     nobject = ptr(new←segno,rel(object));
     old←object->forward = (unspec(object) & "000fffff"b4) | "fab00000"b4;

end; /* copy */

end; /* gc */

     return;
pmd: entry;

     call scs$ioa ("In ↑i garbage collections:",number←of←gcs);
     do i = 1 to 11;
          call scs$ioa("type: ↑i found ↑i times for ↑i bytes",i,
               metering←data←num(i),metering←data←size(i));
          end;
     return;

end; /* sine←gc.pl1 */
↑L 
     Listing of >s>langs>sine>pl1←alloc.pl1  12/30/79 17:26:40

foo: proc;

dcl sine←machine$pl1←allocate entry (fixed(31),ptr);
dcl tp ptr;
dcl i fixed;
dcl scs$ioa entry options(variable);

do i = 1 to 100;
     call sine←machine$pl1←allocate(12,tp);
     call scs$ioa("↑i: ↑p",i,tp);
     end;
end;
↑L 
     Listing of >s>langs>sine>opcodes.sysin  12/30/79 17:28:09

          entry     optypes
          entry     opcodes

optypes   dc   1,1,1,0,4,4,4,4,0,1,0,0,2,4,5,3
*
opcodes   dc   set0-names
          dc   set1-names
          dc   set2-names
          dc   0
          dc   set4-names
          dc   set5-names
          dc   set6-names
          dc   set7-names
          dc   0
          dc   set9-names
          dc   0
          dc   0
          dc   setc-names
          dc   setd-names
          dc   sete-names
          dc   setf-names
*
names     equ  *-1
*
set0      dc   c'    '
          dc   c'balr'
          dc   c'btcr'
          dc   c'bfcr'
          dc   c'nr  '
          dc   c'clr '
          dc   c'or  '
          dc   c'xr  '
          dc   c'lr  '
          dc   c'cr  '
          dc   c'ar  '
          dc   c'sr  '
          dc   c'mhr '
          dc   c'dhr '
          dc   c'    '
          dc   c'    '
*
set1      dc   c'srls'
          dc   c'slls'
          dc   c'chvr'
          dc   c'    '
          dc   c'    '
          dc   c'    '
          dc   c'    '
          dc   c'    '
          dc   c'lpsr'
          dc   c'    '
          dc   c'    '
          dc   c'    '
          dc   c'mr  '
          dc   c'dr  '
          dc   c'    '
          dc   c'    '
*
set2      dc   c'btbs'
          dc   c'btfs'
          dc   c'bfbs'
          dc   c'bffs'
          dc   c'lis '
          dc   c'lcs '
          dc   c'ais '
          dc   c'sis '
          dc   c'ler '
          dc   c'cer '
          dc   c'aer '
          dc   c'ser '
          dc   c'mer '
          dc   c'der '
          dc   c'fxr '
          dc   c'flr '
*
set4      dc   c'sth '
          dc   c'bal '
          dc   c'btc '
          dc   c'bfc '
          dc   c'nh  '
          dc   c'clh '
          dc   c'oh  '
          dc   c'xh  '
          dc   c'lh  '
          dc   c'ch  '
          dc   c'ah  '
          dc   c'sh  '
          dc   c'mh  '
          dc   c'dh  '
          dc   c'    '
          dc   c'    '
*
set5      dc   c'st  '
          dc   c'am  '
          dc   c'    '
          dc   c'    '
          dc   c'n   '
          dc   c'cl  '
          dc   c'o   '
          dc   c'x   '
          dc   c'l   '
          dc   c'c   '
          dc   c'a   '
          dc   c's   '
          dc   c'm   '
          dc   c'd   '
          dc   c'crc2'
          dc   c'crc6'
*
set6      dc   c'ste '
          dc   c'ahm '
          dc   c'    '
          dc   c'    '
          dc   c'atl '
          dc   c'abl '
          dc   c'rtl '
          dc   c'rbl '
          dc   c'le  '
          dc   c'ce  '
          dc   c'ae  '
          dc   c'se  '
          dc   c'me  '
          dc   c'de  '
          dc   c'    '
          dc   c'    '
*
set7      dc   c'    '
          dc   c'stme'
          dc   c'lme '
          dc   c'lhl '
          dc   c'tbt '
          dc   c'sbt '
          dc   c'rbt '
          dc   c'cbt '
          dc   c'    '
          dc   c'    '
          dc   c'    '
          dc   c'    '
          dc   c'    '
          dc   c'    '
          dc   c'    '
          dc   c'    '
*
set9      dc   c'srhs'
          dc   c'slhs'
          dc   c'stbr'
          dc   c'lbr '
          dc   c'exbr'
          dc   c'epsr'
          dc   c'wbr '
          dc   c'rbr '
          dc   c'whr '
          dc   c'rhr '
          dc   c'wdr '
          dc   c'rdr '
          dc   c'    '
          dc   c'ssr '
          dc   c'ocr '
          dc   c'    '
*
setc      dc   c'bxh '
          dc   c'bxle'
          dc   c'lpsw'
          dc   c'thi '
          dc   c'nhi '
          dc   c'clhi'
          dc   c'ohi '
          dc   c'xhi '
          dc   c'lhi '
          dc   c'chi '
          dc   c'ahi '
          dc   c'shi '
          dc   c'srhl'
          dc   c'slhl'
          dc   c'srha'
          dc   c'slha'
*
setd      dc   c'stm '
          dc   c'lm 
          dc   c'stb '
          dc   c'lb  '
          dc   c'clb '
          dc   c'al  '
          dc   c'wb  '
          dc   c'rb  '
          dc   c'wh  '
          dc   c'rh  '
          dc   c'wd  '
          dc   c'rd  '
          dc   c'    '
          dc   c'ss  '
          dc   c'oc  '
*
sete      dc   c'ts  '
          dc   c'svc '
          dc   c'sint'
          dc   c'scp '
          dc   c'    '
          dc   c'    '
          dc   c'la  '
          dc   c'tlat'
          dc   c'    '
          dc   c'    '
          dc   c'rrl '
          dc   c'rll '
          dc   c'srl '
          dc   c'sll '
          dc   c'sra '
          dc   c'sla '
*
setf      dc   c'    '
          dc   c'    '
          dc   c'    '
          dc   c'ti  '
          dc   c'ni  '
          dc   c'cli '
          dc   c'oi  '
          dc   c'xi  '
          dc   c'li  '
          dc   c'ci  '
          dc   c'ai  '
          dc   c'si  '
          dc   c'    '
          dc   c'    '
          dc   c'    '
          dc   c'    '
*
          end
↑L 
     Listing of >s>langs>sine>debug.sysin    12/30/79 17:27:39

 entry debug
debug dc -1
 end
↑L 
     Listing of >s>langs>sine>swap←segs.sysin     12/30/79 17:27:36

*
*  This program takes two segments in two address←spaces
*  and switches them.  It takes two full words as arguments.
*  The full word is the OR of the segment base and the ptr
*  to the AS.
*
 pc 0
 org 0
as equ *
as.next ds 4
as.sdb ds 4*16
*
 org 0
saved←as equ *
saved←as.next ds 4
saved←as.name ds 4
saved←as.sdb ds 64
saved←as.names ds 4
saved←as.lot ds 64

 incl shuffle
 pc 1
*
 entry out
out .ent 0
 l 1,4(15)
 l 1,0(1) get ptr to incore segment
 l 2,8(15)
 l 2,0(2) get place to put it
 l 3,cur←task
 l 3,pa←address←space(3)
 srls 1,14 turn segno into AS offset of sdb and acl word
 nhi 1,x'fc'
 lr 4,2
 ni 4,x'ffff' get ptr to AS
 oi 4,!13 this is in a saved AS
 srls 2,14 turn segno into AS offset of sdb and acl word
 nhi 2,x'fc'
 l 5,as.sdb(1,3) Perform the swap...
 l 6,saved←as.sdb(2,4)
 bnzs * barf out badly if bashing a slot that's in use.
 lis 0,0
 st 0,as.sdb(1,3) keep user count right
 st 5,saved←as.sdb(2,4)
 svc 12,x'0c30' reset the mac registers
 .rtn

 entry in
in .ent 0
 l 1,4(15)
 l 1,0(1) get ptr to swapped out segment
 l 2,8(15)
 l 2,0(2) get place to put it
 l 4,cur←task
 l 4,pa←address←space(4)
 srls 2,14 turn segno into AS offset of sdb and acl word
 nhi 2,x'fc'
 lr 3,1
 ni 3,x'ffff' get ptr to AS
 oi 3,!13 this is in a saved AS
 srls 1,14 turn segno into AS offset of sdb and acl word
 nhi 1,x'fc'
 l 5,saved←as.sdb(1,3) Perform the swap...
 l 6,as.sdb(2,4)
 bnzs * barf out badly if bashing a slot that's in use.
 lis 0,0
 st 0,saved←as.sdb(1,3) keep user count right
 st 5,as.sdb(2,4)
 svc 12,x'0c30' reset the mac registers
 .rtn

 end

↑L 
     Listing of >s>langs>sine>subst.sysin    12/30/79 17:28:03

*
*  assignment substr which does it right
*
*  transfer characters (source←ptr,desination←ptr,num←chars)
*
 entry subst
subst bal 5,!15+x'e0'
 dc 0,0,0
 l 11,4(15)
 l 10,0(11)
 l 5,8(15)
 l 11,0(5)
 l 5,12(15)
 lhl 12,0(5)
*
 lis 5,1 ammount to increment by (1 or -1)
 lr 6,10
 ar 6,12 place to stop
 clr 11,10 go forwards or backwards?
 bls trans go forward
 be !15+x'e4'
*
 lr 6,10
 sis 6,1
 lcs 5,1
 ar 10,12 start char transfer at ends of strings
 sis 10,1
 ar 11,12
 sis 11,1
*
trans clr 10,6 are we done yet?
 be !15+x'e4' if so return.
 lb 1,0(10) else transfer a character
 stb 1,0(11)
 ar 10,5
 ar 11,5
 b trans
 end
↑L 
     Listing of >s>langs>sine>sm.sysin  03/12/80 13:54:10

*
*         This is the sine machine interpreter.
*
*    I am going to try and write it in assembler. This will probably
*    suck shit but it will also be fast as a bat out of hell and small.
*    Oh Well.
*
          copy defuns
          copy data←types

          pc   7

          copy static

          pc   1

          entry     interp,initialize,pl1←make←vbl
          entry     allocate,pl1←allocate,get←init,getr←init
          extrn     iocs$get←chars,iocs$put←chars,$init,sine←error$error
          extrn     $pl1←make←buffer,$incorify,$load←init,iocs$order
          extrn     hcs$initiate,hcs$append←seg,hcs$truncate←file
          extrn     hcs$initiate←w←options
          extrn     hcs$set←bit←count,hcs$get←bit←count,hcs$terminate
          extrn     scs$expand←path
          extrd     linkage$user←input,linkage$user←output

*         For pc relative stuff:

          pc   1
ground←zero    equ  *


*         call initialize;

initialize     .ent 12

*         dcl $init entry (structure,ptr);
*         call $init (state,string←space←ptr /* returned */);

          l    temp,string←space        already initialized?
          bnz  !1+x'b4'                 yep.

          la   temp,state
          st   temp,arg1p(sp)
          la   temp,string←space
          st   temp,arg2p(sp)
          lhi  temp,12
          st   temp,alist←size(sp)
          la   ap,alist(sp)
          bal  link,$init
          l    t1,string←space
          lr   temp,t1
          ais  temp,variable←size
          st   temp,top←of←heap
          st   temp,time←to←gc
          lhi  temp,10*2048
          sth  temp,time←to←gc+2

          oi   t1,variable←bits
          st   t1,linel←ptr
          la   temp,linel←string
          st   temp,arg3p(sp)
          la   ops,arg3p(sp)
          l    stack,state.sp           so make←string can save stuff
          bal  link,make←string
          st   rv,variable.name(t1)
          lhi  temp,80
          st   temp,variable.value(t1)            set up initial value
          lis  temp,0
          st   temp,variable.next(t1)
          .rtn

linel←string   dc   5,c'linel'

*         dcl interp entry (ptr);
*         call interp (code←ptr);

interp    .ent stack←end-stack←start

          st   sp,contour←ptr                incase break gets hit

          bal  link,linkage$user←input       save the io stream ptrs
          l    temp,0(2)
          st   temp,user←input
          bal  link,linkage$user←output
          l    temp,0(2)
          st   temp,user←output
          la   temp,io←buffer(sp)
          st   temp,io←buffer←ptr(sp)
          lis  temp,1
          st   temp,bit←map.t(sp)
          lhi  temp,128
          st   temp,bit←map.l(sp)

          la   temp,pos←struc(ls)
          st   temp,pos←struc←ptr(ls)

          la   temp,state
          st   temp,arg1p(sp)
          l    temp,4(ap)               get ptr to code
          st   temp,arg2p(sp)
          lhi  temp,12
          st   temp,alist←size(sp)
          la   ap,alist(sp)
          bal  link,$load←init          fas←load the program

          l    stack,state.sp           so people can save stuff

          lis  temp,0                   set up break handler
          st   temp,cond.next(sp)
          la   temp,break←handler
          st   temp,cond.handler(sp)
          li   temp,c'brea'
          st   temp,cond.name1(sp)
          li   temp,c'k   '
          st   temp,cond.name2(sp)
          la   temp,cond(sp)
          st   temp,condition←ptr(sp)

          l    source,restart.buf
          bz   next←inst
          l    t2,state.pc.buf
          lis  temp,buffer.flags.wired
          rbt  temp,buffer.flags(t2)
          sbt  temp,buffer.flags(source)
          st   source,state.pc.buf
          l    temp,restart.loc
          st   temp,state.pc.loc
          l    temp,restart.vbl←tab
          st   temp,state.ip
          bal  link,swap←in

next←inst lh   temp,breakp
          bzs  no←break←hit
          lis  temp,0
          sth  temp,breakp
find←break     equ  *
          la   t1,error←table←break←entry
          b    error.signal←entry
do←a←break     equ  *
          lm   temp,register←save(sp)
          bs   find←break

no←break←hit   equ  *
*         st   stack,state.sp
          la   ops,operand←table(sp)
          l    pc.buf,state.pc.buf      get the pc
          l    pc.buf,buffer.base(pc.buf)
          l    pc.loc,state.pc.loc
          lhl  opcode,0(pc.buf,pc.loc)  get the opcode to dispatch on
          thi  opcode,x'2000'           is it really an opcode?
          bnzs ni.not←shit1
ni.exe←shit    equ  *
          b    exe←shit
ni.not←shit1   equ  *
          thi  opcode,x'c000'           this must be zero
          bnzs ni.exe←shit
          sth  opcode,saved←opcode(sp)  save for later reference
          nhi  opcode,x'0fff'           zap those bits
          mh   opcode,op←entry←len
          ais  pc.loc,2

          lis  t2,0                          amount to shrink stack by
          lhl  optype,operand←types(opcode)  gets type of first operand
          bz   interp.dispatch               no operand, just go there.
          bal  link,decode                   decode the operand
          st   rv,op1(ops)                   save it.

          lhl  optype,operand←types+2(opcode)
          bz   interp.dispatch
          bal  link,decode
          st   rv,op2(ops)

          lhl  optype,operand←types+4(opcode)
          bzs  interp.dispatch
          bal  link,decode
          st   rv,op3(ops)

          lhl  optype,operand←types+6(opcode)
          bzs  interp.dispatch
          bal  link,decode
          st   rv,op4(ops)

interp.dispatch     equ  *
          st   pc.loc,state.pc.loc           save it away
          ar   stack,t2                      flush operands on the stack
          lhl  temp,inst←type(opcode)        special info about the inst.
          sth  temp,inst←info(sp)
          lhl  t1,address(opcode)            get addr of inst. handler
          bal  link,ground←zero(t1)
error0    equ  *
          lh   temp,inst←info(sp)
          bz   next←inst

*    The return inst. assumes only this bit is tested since the return inst.
*    sets this to the opcode of the call inst.

          lh   temp,saved←opcode(sp)
          thi  temp,x'1000'             if set don't push
          bnz  next←inst
          st   rv,0(stack)
          ais  stack,4
          b    next←inst

exe←shit  bal  link,error               we are executing shit
error6    equ  *


*              DECODE

*         optype tells what kind of stuff the operand should be.
*         it is 1 halfword long.

*         bit 16 means get addr of vbl block
*         bit 15 means addr of object.
*         bit 1-14 bit is one if data type (0-13) is okay.

vbl←address    equ  x'8000'
addr←only      equ  x'4000'

pc←reg←number  equ  0
sp←reg←number  equ  2*4
ip←reg←number  equ  3*4

decode    lhl  rv,0(pc.buf,pc.loc)      get the operand
          ais  pc.loc,2                 bump the pc
*         st   pc.loc,state.pc.loc      incase we index off the pc...

*    Now we do a moby dispatch for speed

          lr   t3,rv                    save for the numbers
          lr   t1,rv
          nhi  rv,x'1fff'               trim for indexed modes
          nhi  t1,x'e000'
          lr   t4,optype
          srls t4,3
          or   t1,t4
          srls t1,9
          nhi  t1,x'fffc'
          b    decode←tab(t1)

decode←tab     equ  *
          b    number←no←extend         0-00-00   positive number
          b    do←error1                0-00-01   addr(number)
          b    do←error3                0-00-10   number ↑= variable
          b    do←error3                0-00-11   ditto
          b    number←no←extend         0-01-00   positive number
          b    do←error1                0-01-01   addr(number)
          b    do←error3                0-01-10   number ↑= variable
          b    do←error3                0-01-11   ditto
          b    number←extend            0-10-00   positive number
          b    do←error1                0-10-01   addr(number)
          b    do←error3                0-10-10   number ↑= variable
          b    do←error3                0-10-11   ditto
          b    number←extend            0-11-00   positive number
          b    do←error1                0-11-01   addr(number)
          b    do←error3                0-11-10   number ↑= variable
          b    do←error3                0-11-11   ditto
          b    pc←rel                   1-00-00   std. pc relative ref.
          b    do←error2                1-00-01   can't get addr of code
          b    do←error3                1-00-10   pc ↑= variable
          b    do←error3                1-00-11   ditto
          b    sb←rel                   1-01-00   std. stack base ref.
          b    addr←sb←rel              1-01-01   for storing into sb cell
          b    do←error3                1-01-10   vbls not on stack
          b    do←error3                1-01-11   ditto
          b    sp←rel                   1-10-00   std. stack top ref.
          b    addr←sp←rel              1-10-01   for storing onto stack
          b    do←error3                1-10-10   vbls not on stack
          b    do←error3                1-10-11   ditto
          b    vbl←value                1-11-00   std. vbl value ref
          b    addr←vbl←value           1-11-01   std store into vbl
          b    vbl←addr                 1-11-10   gets ptr to vbl
          b    do←error3                1-11-11   cant get addr(addr(vbl))

number←extend  equ  *                   negative number
          ohi  t3,x'8000'               extend the sign
number←no←extend    equ  *
          lr   rv,t3
          thi  optype,1                 check type
          bnzr link                     numbers are allowed
          b    do←error3

pc←rel    thi  rv,x'1000'               check the sign bit
          bzs  pc←rel.ns
          ohi  rv,x'e000'               extend the sign
pc←rel.ns slls rv,1                     pc increments in halfwords
          ar   rv,pc.loc                add in the buffer offset
          l    t1,state.pc.buf
          a    rv,buffer.base(t1)       add in buffer base
          thi  optype,4                 make it a string
          bnzs pc←rel.make←it←a←string
          thi  optype,1                 does it take addresses?
          bnzr link
          b    do←error3
pc←rel.make←it←a←string  equ  *
          oi   rv,string←bits
          br   link

sb←rel    thi  rv,x'1000'
          bzs  sb←rel.ns
          ohi  rv,x'e000'
sb←rel.ns slls rv,2
          a    rv,state.sb
          l    rv,0(rv)
          b    decode.check←type

addr←sb←rel    equ  *
          thi  rv,x'1000'
          bzs  addr←sb←rel.ns
          ohi  rv,x'e000'
addr←sb←rel.ns equ  *
          slls rv,2
          a    rv,state.sb
          br   link

sp←rel    thi  rv,x'1000'
          bzs  sp←rel.ns
          ohi  rv,x'e000'
sp←rel.ns slls rv,2
          cr   rv,t2                         keep deepest stack penetration
          bnms addr←sb←rel.deeper
          lr   t2,rv
addr←sb←rel.deeper  equ  *
          l    rv,0(rv,stack)
          b    decode.check←type

addr←sp←rel    equ  *
          thi  rv,x'1000'
          bzs  addr←sp←rel.ns
          ohi  rv,x'e000'
addr←sp←rel.ns equ  *
          slls rv,2
          ar   rv,stack                      This is kept in a register
          br   link

vbl←value thi  rv,x'1000'
          bzs  vbl←value.ns
          ohi  rv,x'e000'
vbl←value.ns   equ  *
          slls rv,2
          l    t1,state.ip
          clh  rv,0(t1)                      Check static vbl count
          bnp  vbl←value.static
          l    rv,0(rv,t1)
          lr   temp,rv
          srl  temp,28
          clhi temp,variable←type
          bne  decode.check←type
          l    rv,variable.value(rv)
          b    decode.check←type

vbl←value.static    equ  *
          l    rv,0(rv,t1)
          b    decode.check←type

addr←vbl←value equ  *
          thi  rv,x'1000'
          bzs  addr←vbl←value.ns
          ohi  rv,x'e000'
addr←vbl←value.ns   equ  *
          slls rv,2
          l    t1,state.ip
          clh  rv,0(t1)                      Check static vbl count
          bnp  addr←vbl←value.static
          l    rv,0(rv,t1)
          la   rv,variable.value(rv)
          br   link

addr←vbl←value.static    equ  *
          la   rv,0(rv,t1)
          br   link

vbl←addr  thi  rv,x'1000'
          bzs  vbl←addr.ns
          ohi  rv,x'e000'
vbl←addr.ns    equ  *
          slls rv,2
          l    t1,state.ip
          clh  rv,0(t1)
          bnp  do←error3                can't get vbl addr of static vbl.
          l    rv,0(rv,t1)
          br   link

do←error1 st   pc.loc,state.pc.loc
          bal  link,error
error1    equ  *                        illegal immediate op

do←error2 st   pc.loc,state.pc.loc
          bal  link,error
error2    equ  *                        illegal pc rel

decode.check←type   equ  *
          lr   t1,rv                    to check types
          srl  t1,28
          clhi t1,x'000f'               negative numbers are numbers
          bnes decode.not←neg
          lis  t1,0
decode.not←neg lis  test←mask,1              hack to see if allowed
          sll  test←mask,0(t1)
          nr   optype,test←mask
          bnzr link
do←error3 st   pc.loc,state.pc.loc
do←bad←type    equ  *
          bal  link,error               you can't do this
error3    equ  *                        disallowed operand

          align 4
error←table    equ  *
          dc   error0,0
error←table.message equ  *
          dc   c'ii      '

          dc   0,0
error←table←break←entry  equ  *
          dc   c'break   '
          dc   error1,0,c'immed op'
          dc   error2,0,c'pcrel op'
          dc   error3,0,c'bad type'     Instruction called with bad object type
          dc   error4,0,c'unkn obj'     attempt to get chars out of non-strin
          dc   error5,0,c'bad loc '
          dc   error6,0,c'↑opcode '
          dc   error7,0,c'unk mark'     del or set mark called with bad buffer
          dc   error8,0,c'#del > z'
          dc   error9,0,c'arry↑bit'     array was not a bit array
          dc   error10,0,c'bad case'
          dc   error11,0,c'↑chrarry'    array was not 128 bits long
          dc   error12,0,c'srchfail'
          dc   error13,0,c'array sz'    array cell size w{s not 1 or 32 bits
          dc   error14,0,c'bash ROB'    attempt to modify Read Only Buffer
          dc   error15,0,c'call↑fun'    call not invoked with a function
          dc   error16,0,c'ary↑mtch'    the arrays to copy←array didn't match

error←table←size equ 16*error←table←block←size
          dc   0,c'unkn err'
error←table←block←size   equ  12

error     save
          st   stack,state.sp
          lis  t1,0
          ni   link,x'ffff'
error.look     equ  *
          clh  link,error←table(t1)
          bes  error.found←it
          ais  t1,error←table←block←size
          clhi t1,error←table←size
          bnps error.look

error.found←it equ  *
          la   t1,error←table.message(t1)    get real ptr to name of error
error.signal←entry  equ  *
          l    t2,state.sb                   now look for a handler on the stack
error.check←frame   equ  *
          l    t3,frame.handlers(t2)
          bz   error.next←frame
error.check←handler equ  *
          l    t4,handler.error←name(t3)     get first 4 chars of handler name
          bz   error.next←handler
          cl   t4,0(t1)
          bne  error.next←handler
          l    temp,4(t1)
          cl   temp,handler.error←name+4(t3)
          bes  error.found←handler
error.next←handler  equ  *
          l    t3,handler.next(t3)
          bnz  error.check←handler
error.next←frame    equ  *
          l    t2,frame.saved←sb(t2)         try previous frame
          bz   error.report
          b    error.check←frame

error.found←handler equ  *
          lis  temp,0
          st   temp,handler.error←name(t3)   don't handle this one again
          l    rv,handler.contour(t3)        find where to unwind to.
          st   rv,op1(ops)
          bal  link,unwind                   how this gets back is beyond me
          change←pc t3,handler.addr
          b    next←inst

*         dcl $error entry (char(8),structure,code←ptr);
*         call $error (msg,state,state.pc.buf->buffer.base);

error.report   equ  *
          l    temp,0(t1)
          ci   temp,c'brea'
          be   signal←break                  continue to signal
          st   t1,arg1p(sp)
          la   temp,state
          st   temp,arg2p(sp)
          l    ap,state.pc.buf
          l    temp,buffer.base(ap)
          st   temp,arg4p(sp)
          la   temp,arg4p(sp)
          st   temp,arg3p(sp)
          lhi  temp,16
          st   temp,alist←size(sp)
          la   ap,alist(sp)
          bal  link,sine←error$error
          dc   0                        if we come back...

signal←break   equ  *
          lis  temp,0
          st   temp,condition←ptr(sp)   revert...
          svc  6,0
          dc   c'break   '
          la   temp,cond(sp)
          st   temp,condition←ptr(sp)
          b    next←inst

break←handler  equ  *
          lh   5,break←enabled
          bzs  bh.wait
          am   5,state.pc.loc           this is the back up amount
          la   14,do←a←break
          l    15,contour←ptr
          bal  3,!1+32                  non-local goto
          dc   0

bh.wait   lis  5,1
          sth  5,breakp
          br   link

*    This is the unwinder.  It is passed a stack pointer, saves
*    all the registers, and returns the stack to the state it was
*    when the sp was saved.  That is, it gets the call frame right
*    and then sets stack to op1(ops) then restores all the other
*    register.  The most important thing, of course, that it unbinds
*    variables bound in the intervening frames.

unwind    stm  0,register←save(sp)
unwind.next←frame   equ  *
          l    t1,state.sb
          l    rv,op1(ops)
          clr  rv,t1
          bp   unwind.done
          lh   temp,frame.num←temps(t1)
          slls temp,2
          la   t2,frame.temps(t1)
          ar   t2,temp
          lh   t3,frame.num←bound(t1)        get number of vbls bound in this frame
          mh   t3,binding←block←size
unwind.unbind  equ  *
          sis  t3,12
          bms  unwind.unbound
          l    t4,bindings.value←addr(t2,t3) get atom to restore
          l    temp,bindings.old←value(t2,t3)     get saved value
          st   temp,0(t4)
          bs   unwind.unbind

binding←block←size  dc   12

unwind.unbound equ  *                   now restore the other stuff
          change←pc t1,frame.saved←pc
*         l    temp,frame.saved←pc(t1)
*         st   temp,state.pc
          l    temp,frame.saved←sb(t1)
          st   temp,state.sb
          l    temp,frame.saved←ip(t1)
          st   temp,state.ip
          b    unwind.next←frame
unwind.done    equ  *
          st   rv,state.sp
          st   rv,stack*4+register←save(sp)  this will become register: stack
          lm   0,register←save(sp)
          br   link

*    Allocate is called with size in reg 5 and ptr is returned in rv

allocate  save
          l    0,top←of←heap
          ar   0,5                      add in size of allocate
          cl   0,time←to←gc
          bl   al.doit
          lh   rv,inhibit←gc
          bnz  al.doit
          st   5,0(stack)
          ais  stack,4
          st   stack,state.sp           so gc can notice
          lhi  0,36
          st   0,alist←size(sp)
          la   0,state
          st   0,arg1p(sp)
          la   0,top←of←heap
          st   0,arg2p(sp)
          la   0,linel←ptr
          st   0,arg3p(sp)
          la   0,current←screen←ptr(ls)
          st   0,arg4p(sp)
          la   0,screen←chain(ls)
          st   0,arg5p(sp)
          la   0,lines.screen(ls)
          st   0,arg6p(sp)
          la   0,op1(ops)
          st   0,arg7p(sp)
          la   0,restart.buf(ls)
          st   0,arg8p(sp)
          la   15,alist(sp)
          bal  link,sine←gc
          sis  stack,4
          l    5,0(stack)
          l    0,top←of←heap
          st   0,time←to←gc
          lhi  1,10*2048                     give him at least 10 pages
          clh  1,top←of←heap+2               check offset part of ptr
          bnps al.round←up
          sth  1,time←to←gc+2                set offset part to 10 pages
          bs   al.doit
al.round←up    equ  *
          sis  0,1
          ohi  0,x'1fff'                     round up to nearest 4K
          ais  0,1
          st   0,time←to←gc

al.doit   sis  5,1
          ohi  5,3
          ais  5,1
          l    rv,top←of←heap
          am   5,top←of←heap
          b    popj

pl1←allocate   .ent 16+56
          la   stack,arg4p(sp)
          lis  0,1
          ahm  0,inhibit←gc
          l    1,4(15)
          l    5,0(1)
          l    2,8(15)
          bal  link,allocate
          st   rv,0(2)                  return the ptr
          lcs  0,1
          ahm  0,inhibit←gc
          .rtn

*    Free operator takes a length in 5 and a ptr in rv and frees the block

free      br   link

          save
          la   6,code                   use code for the ptr
          st   rv,code
          l    7,string←space           get the ptr to SS
          bal  3,!1+80                  PL/1 free operator
          restore
          br   link

*         This sets up a utility by which chars can be extracted from
*         an arbitrary source very easily.

get←init  lr   type,source
          srl  type,28
          clhi type,0                   is it a number?
          bnes try←string
          cli  source,!2
          bps  is←string
          la   get,get←number
          br   link

try←string     clhi type,string←type
          bnes try←window
is←string la   get,get←string
          la   text←ptr,string.text(source)
          lh   type,string.length(source)
          st   type,get.stop
          br link

try←window     equ  *
          clhi type,window←type
          bne  try←buffer
          l    type,window.real←text(source)
          lr   temp,type
          srl  temp,28
          clhi temp,buffer←type
          bne  tw.string
          save
          lr   source,type
          bal  link,swap←in
          restore
          l    get,window.start(source)
          l    text←ptr,marker.mv(get)
          cl   text←ptr,buffer.gap←end(type)
          bls  tw.below←gap
          ar   index,text←ptr
          bs   tw.still←below←gap
tw.below←gap   equ  *
          a    index,marker.mv(get)
          make←absolute←bufptr     index,type
tw.still←below←gap  equ  *
          l    get,window.stop(source)
          l    temp,marker.mv(get)
          st   temp,get.stop
          l    text←ptr,buffer.base(type)
          lr   source,type                        make it look like a buffer
          cl   temp,buffer.gap←start(type)        if below gap then string
          bnps tw.only←below←gap
          la   get,get←buffer
          br   link
tw.only←below←gap   equ  *
          la   get,get←string
          br   link

tw.start←stop  l    type,window.start(source)

*    We'll take index to be set to starting position from beginning of window

          a    index,marker.mv(type)

          l    type,window.stop(source)
          l    temp,marker.mv(type)
          st   temp,get.stop
          br   link
tw.string      la   text←ptr,string.text(type)
          lh   temp,string.length(type)
          st   temp,get.stop
          la   get,get←string
          b    tw.start←stop

try←buffer     equ  *
          clhi type,buffer←type
          bne  try←gnirt
          save
          bal  link,swap←in
          restore
          l    text←ptr,base(source)
          l    type,top(source)
          st   type,get.stop
          la   get,get←buffer
          make←absolute←bufptr     index,source
*         cl   index,buffer.gap←start(source)
*         bnpr link
*         a    index,buffer.gap←end(source)
*         s    index,buffer.gap←start(source)
          br   link

try←gnirt clhi type,gnirt←type
          bne  error4←do
          l    text←ptr,gnirt.text←ptr(source)
          lh   temp,gnirt.real←length(source)
          st   temp,get.stop
          la   get,get←string
          br   link

error4←do bal  link,error
error4    equ  *                        illegal object

*    Routines to get chars from asorted places.

get.too←far    lcs  char,1                             error return
          br   link

get←number     equ  *
          la   get,get.too←far
          lr   char,source this is just a hack
          b    4(link)                                 correct return

get←string     cl   index,get.stop
          bnls get.too←far
          lb   char,0(text←ptr,index)
          ais  index,1
          b    4(link)                                 correct return

get←buffer     equ  *
          cl   index,buffer.gap←start(source)     are we about to fall into gap??
          bls  gb.no←gap
          bes  gb.go←to←upper                     no.
          cl   index,buffer.gap←end(source)
          bnls gb.just←upper
gb.go←to←upper equ  *
          l    index,buffer.gap←end(source)
gb.just←upper  equ  *
          la   get,gb.no←gap
gb.no←gap      equ  *
          cl   index,get.stop
          bnl  get.too←far                        we've run off end
gb.just←get    equ  *
          lb   char,0(index,text←ptr)
          ais  index,1
          b    4(link)                                 correct return

getr←init lr   type,source
          srl  type,28
          clhi type,0                   is it a number?
          bnes rtry←string
          cli  source,!2
          bps  ris←string
          la   get,get←number
          br   link

rtry←string    equ  *
          clhi type,string←type
          bnes rtry←window
ris←string     equ  *
          la   get,getr←string
          la   text←ptr,string.text(source)
          lis  type,0
          st   type,getr.stop
          br link

rtry←window    equ  *
          clhi type,window←type
          bne  rtry←buffer
          l    type,window.real←text(source)
          lr   temp,type
          srl  temp,28
          clhi temp,buffer←type
          bne  rtw.string
          save
          lr   source,type
          bal  link,swap←in
          restore
          l    text←ptr,buffer.base(type)
          l    get,window.start(source)
          a    index,marker.mv(get)
          make←absolute←bufptr     index,type
          lis  temp,0
          st   temp,getr.stop
          lr   source,type                        make it look like a buffer
          la   get,getr←buffer
          br   link

rtw.start←stop l    type,window.stop(source)
          l    temp,marker.mv(type)
          sr   temp,index
          lr   index,temp
          sis  index,1
          l    type,window.start(source)
          l    temp,marker.mv(type)
          st   temp,getr.stop
          br   link
rtw.string     la   text←ptr,string.text(type)
          lh   temp,string.length(type)
          st   temp,getr.stop
          la   get,getr←string
          b    rtw.start←stop

rtry←buffer    clhi type,buffer←type
          bne  rtry←gnirt
          save
          bal  link,swap←in
          restore
          l    text←ptr,base(source)
          sis  index,1
*         make←absolute←bufptr     index,source
          c    index,buffer.gap←start(source)
          bms  rtb.below←gap
          a    index,buffer.gap←end(source)
          s    index,buffer.gap←start(source)
rtb.below←gap  equ  *
          lis  type,0
          st   type,getr.stop
          la   get,getr←buffer
          br   link

rtry←gnirt     equ  *
          clhi type,gnirt←type
          bne  error4←do
          l    text←ptr,gnirt.text←ptr(source)
          lis  temp,0
          st   temp,getr.stop
          la   get,getr←string
          br   link

*    Routines to get chars from asorted places.

getr←string    c    index,getr.stop
          bm   get.too←far                             no more chars
          lb   char,0(text←ptr,index)
          sis  index,1
          b    4(link)                                 correct return

getr←buffer    equ  *
          c    index,getr.stop
          bm   get.too←far
          lb   char,0(index,text←ptr)
          sis  index,1
          c    index,buffer.gap←start(source)
          bm   4(link)                                 correct return
          cl   index,buffer.gap←end(source)
          bnl  4(link)                                 still in upper part
          l    index,gap←start(source)
          sis  index,1
          b    4(link)

*         Move gap to current location and make it big enough

read←only←bit  equ  0

update←gap     save
          lr   source,sink
          bal  link,swap←in
          lis  gstart,buffer.flags.read←only
          tbt  gstart,buffer.flags(sink)
          bzs  OK←to←ug
          bal  link,error
error14   equ  *                                  attempt to write in ROB

OK←to←ug  l    gstart,gap←start(sink)
          l    gsize,gap←end(sink)
          sr   gsize,gstart                       gap size
          cl   gstart,buffer.location(sink)       are we already at the gap?
          bne  ug.must←shuffle                    no (sigh)
          clr  gsize,len                          is there enough room?
          bnm  popj                               yes (win)

ug.must←shuffle lis temp,0
          sr   temp,gsize                         negative gap size
          l    markers,marker←chain(sink)
          bzs  ug.no←unmark
ug.unmark←loop cl   gstart,marker.mv(markers)          get marker value and fix it.
          bnls ug.fix←next
          am   temp,marker.mv(markers)            subtract gap size
ug.fix←next    l    markers,marker.next(markers)       cdr down list
ug.unmark←test bnzs ug.unmark←loop

ug.no←unmark   cl   gstart,buffer.location(sink)       which side are we on?
          bl   ug.above←gap
          lr   temp,gsize
          sr   temp,len
          bp   ug.move←lower

ug.move←upper  lr   temp,gsize               save old size
          lhi  gsize,250(len)           be sure there's plenty of room
          sr   temp,gsize               get amount upper has to move
          l    from←ptr,text←ptr(sink)
          a    from←ptr,gap←end(sink)
          lr   to←ptr,from←ptr
          sr   to←ptr,temp              difference was negative

          l    num←ch,top(sink)
          s    num←ch,gap←end(sink)
          bal  link,subst

ug.move←lower  l    from←ptr,text←ptr(sink)
          a    from←ptr,buffer.location(sink)
          lr   to←ptr,from←ptr
          ar   to←ptr,gsize
          lr   num←ch,gstart
          s    num←ch,buffer.location(sink)
          bal  link,subst
          b    ug.unfix←m               restore the markers

ug.above←gap   l    from←ptr,text←ptr(sink)
          lr   to←ptr,from←ptr
          a    from←ptr,gap←end(sink)
          ar   to←ptr,gstart
          l    num←ch,buffer.location(sink)
          sr   num←ch,gstart
          bal  link,subst

          lr   temp,gsize
          sr   temp,len
          bp   ug.unfix←m               that's all folks

ug.ag.upper    lhi  gsize,250(len)           new gap size (room to grow)
          l    from←ptr,text←ptr(sink)
          lr   to←ptr,from←ptr
          a    from←ptr,gap←end(sink)
          ar   from←ptr,num←ch          skip num moved before
          a    to←ptr,buffer.location(sink)
          ar   to←ptr,gsize
          lr   temp,num←ch              save num←ch
          l    num←ch,top(sink)
          s    num←ch,gap←end(sink)
          sr   num←ch,temp
          bal  link,subst

ug.unfix←m     l    temp,buffer.location(sink)         reset gap ptr etc.
          lr   gstart,temp
          l    num←ch,top(sink)
          s    num←ch,gap←end(sink)
          a    num←ch,gap←start(sink)             length of buffer
          s    num←ch,buffer.location(sink)   get size of upper part
          st   temp,gap←start(sink)
          ar   temp,gsize
          st   temp,gap←end(sink)
          ar   temp,num←ch
          st   temp,top(sink)

          l    markers,marker←chain(sink)    reset all the markers
          bz   ug.set←bc
ug.unfix←loop  cl   gstart,marker.mv(markers)     has this one need help?
          bnls ug.unfix←next                 no
          am   gsize,marker.mv(markers) make it absolute (not like pt)
ug.unfix←next  l    markers,marker.next(markers)
ug.unfix←test  bnzs ug.unfix←loop

ug.set←bc la   temp,buffer.base(sink)
          st   temp,arg1p(sp)
          l    temp,buffer.top(sink)
          slls temp,3
          st   temp,segptr(sp)
          la   temp,segptr(sp)
          st   temp,arg2p(sp)
          lis  temp,12
          st   temp,alist←size(sp)
          la   ap,alist(sp)
          bal  link,hcs$set←bit←count
          b    popj

*         A good char copy routine

subst          save                     for saftey's sake
          lis  t1,1 ammount to increment by (1 or -1)
          lr   t2,from←ptr
          ar   t2,num←ch                place to stop
          clr  to←ptr,from←ptr          go forwards or backwards?
          bls  trans                    go forward
          be   popj
*
          lr   t2,from←ptr
          sis  t2,1
          lcs  t1,1
          ar   from←ptr,num←ch
*start char transfer at ends of strings
          sis  from←ptr,1
          ar   to←ptr,num←ch
          sis  to←ptr,1
*
trans          clr  from←ptr,t2              are we done yet?
          be   popj                if so return.
          lb   char,0(from←ptr)         else transfer a character
          stb  char,0(to←ptr)
          ar   from←ptr,t1
          ar   to←ptr,t1
          bs   trans

*         To swap buffers into this address space

swap←in   save
          l    temp,base(source)        does it need swapping in?
          cli  temp,x'0002fffe'
          bne  popj
          st   source,code
          la   temp,code
          st   temp,arg1p(sp)
          lis  temp,8
          st   temp,alist←size(sp)
          la   ap,alist(sp)
          bal  link,$incorify
          b    popj

          entry     do←a←gc
          extrn     sine←gc
do←a←gc   .ent 16
          lhi  0,36
          st   0,alist←size(sp)
          la   0,state
          st   0,arg1p(sp)
          la   0,top←of←heap
          st   0,arg2p(sp)
          la   0,linel←ptr
          st   0,arg3p(sp)
          la   0,current←screen←ptr(ls)
          st   0,arg4p(sp)
          la   0,screen←chain(ls)
          st   0,arg5p(sp)
          la   0,lines.screen(ls)
          st   0,arg6p(sp)
          la   0,op1(ops)
          st   0,arg7p(sp)
          la   0,restart.buf(ls)
          st   0,arg8p(sp)
          la   15,alist(sp)
          bal  link,sine←gc
          lis  0,0
          st   0,number←of←allocates
          .rtn

*         This entry point takes a pl1 char varying string and returns
*         a pointer to the variable of that name.

pl1←make←vbl   .ent 4+56+56        need two save areas
          lis  0,1
          ahm  0,inhibit←gc
          la   stack,84(sp)
          l    source,4(ap)

          la   ops,80(sp)
          st   source,op1(ops)
          bal  link,make←variable
          l    temp,error←register      did it exist?
          bz   pmv.copy←name            no...
pmv.rtn   l    2,8(ap)
          st   rv,0(2)                  return vbl
          l    2,12(ap)
          st   temp,0(2)                return a bad code
          lcs  0,1
          ahm  0,inhibit←gc
          .rtn

pmv.copy←name  equ  *
          lr   t1,rv                    save ptr to vbl
          lh   5,string.length(source)
          ais  5,2                      for length field
          bal  link,allocate
          sis  5,2
          sth  5,string.length(rv)
          sis  5,1
pmv.loop  lb   char,string.text(5,source)
          stb  char,string.text(5,rv)
          sis  5,1
          bnms pmv.loop

          oi   rv,string←bits
          st   rv,variable.name(t1)
          lr   rv,t1
          lis  temp,0
          b    pmv.rtn

popj      restore
          br   link

op←entry←len   dc   12

               entry     opcode←table
opcode←table   equ  *

op←tab←origin  equ  *
operand←types  dc   0,0,0,0
inst←type      dc   0
address        dc   error

*         incl opcodes
* here is the incl file itself

 org 12+op←tab←origin
 dc 1,1,0,0,1,add
 org 24+op←tab←origin
 dc 1,1,0,0,1,sub
 org 36+op←tab←origin
 dc 1,1,0,0,1,mul
 org 48+op←tab←origin
 dc 1,1,0,0,1,div
 org 60+op←tab←origin
 dc 1,1,0,0,1,mod
 org 720+op←tab←origin
 dc 1,1,0,0,1,min
 org 732+op←tab←origin
 dc 1,1,0,0,1,max
 org 72+op←tab←origin
 dc x'0801',x'0801',0,0,1,and
 org 84+op←tab←origin
 dc x'0801',x'0801',0,0,1,or
 org 96+op←tab←origin
 dc x'0801',x'0801',0,0,1,xor
 org 108+op←tab←origin
 dc x'0010',0,0,0,1,car
 org 120+op←tab←origin
 dc x'0010',0,0,0,1,cdr
 org 1308+op←tab←origin
 dc x'0010',0,0,0,1,caar
 org 1320+op←tab←origin
 dc x'0010',0,0,0,1,cadr
 org 1332+op←tab←origin
 dc x'0010',0,0,0,1,cdar
 org 1344+op←tab←origin
 dc x'0010',0,0,0,1,cddr
 org 132+op←tab←origin
 dc x'3fff',x'3fff',0,0,1,cons
 org 144+op←tab←origin
 dc x'0010',x'3fff',0,0,1,rplaca
 org 156+op←tab←origin
 dc x'0010',x'3fff',0,0,1,rplacd
 org 168+op←tab←origin
 dc x'3fff',0,0,0,1,push
 org 180+op←tab←origin
 dc x'4000',0,0,0,0,pop
 org 192+op←tab←origin
 dc 1,0,0,0,0,squish
 org 204+op←tab←origin
 dc x'8000',1,0,0,0,call
 org 456+op←tab←origin
 dc x'0020',1,0,0,0,call←vbl
 org 216+op←tab←origin
 dc 0,0,0,0,1,return
 org 228+op←tab←origin
 dc 1,0,0,0,1,num←args
 org 240+op←tab←origin
 dc x'8000',0,0,0,0,bind
 org 972+op←tab←origin
 dc x'0020',0,0,0,0,bind←vbl
 org 1644+op←tab←origin
 dc x'4000',0,0,0,0,bind←static
 org 252+op←tab←origin
 dc 1,0,0,0,0,goto
 org 1188+op←tab←origin
 dc 0,0,0,0,1,t
 org 1200+op←tab←origin
 dc 0,0,0,0,1,nil
 org 264+op←tab←origin
 dc x'3fff',1,0,0,1,ift
 org 276+op←tab←origin
 dc x'3fff',1,0,0,1,ifnil
 org 864+op←tab←origin
 dc 1,0,0,0,0,berr
 org 876+op←tab←origin
 dc 1,0,0,0,0,bnoerr
 org 1164+op←tab←origin
 dc x'3fff',x'3fff',0,0,1,eq
 org 1176+op←tab←origin
 dc x'3fff',0,0,0,1,not
 org 288+op←tab←origin
 dc x'3fff',x'3fff',0,0,1,gp
 org 300+op←tab←origin
 dc x'3fff',x'3fff',0,0,1,gep
 org 312+op←tab←origin
 dc x'3fff',x'3fff',0,0,1,lp
 org 324+op←tab←origin
 dc x'3fff',x'3fff',0,0,1,lep
 org 1224+op←tab←origin
 dc 2,0,0,0,1,modifiedp
 org 1380+op←tab←origin
 dc x'040f',2,1,0,1,looking←atp
 org 1404+op←tab←origin
 dc x'3fff',0,0,0,1,functionp
 org 1416+op←tab←origin
 dc x'3fff',0,0,0,1,stringp
 org 1428+op←tab←origin
 dc x'3fff',0,0,0,1,variablep
 org 336+op←tab←origin
 dc 2,x'040f',0,0,1,search
 org 348+op←tab←origin
 dc 2,x'040f',0,0,1,rsearch
 org 360+op←tab←origin
 dc 2,x'040f',0,0,1,searchr
 org 372+op←tab←origin
 dc 2,x'040f',0,0,1,rsearchr
 org 384+op←tab←origin
 dc 0,0,0,0,1,tyi
 org 396+op←tab←origin
 dc 1,0,0,0,1,tyo
 org 408+op←tab←origin
 dc x'040f',1,1,1,1,print
 org 1236+op←tab←origin
 dc x'040f',1,1,1,1,print←clearing
 org 1044+op←tab←origin
 dc 0,0,0,0,1,tyis
 org 420+op←tab←origin
 dc x'3fff',x'4000',0,0,1,store
 org 1632+op←tab←origin
 dc x'3fff',x'0020',0,0,1,estore
 org 432+op←tab←origin
 dc 0,0,0,0,0,display
 org 444+op←tab←origin
 dc x'0100',1,0,0,1,force←display
 org 1284+op←tab←origin
 dc x'0101',1,1,0,0,display←screen
 org 480+op←tab←origin
 dc 0,0,0,0,1,make←buffer
 org 492+op←tab←origin
 dc x'040f',0,0,0,1,make←string
 org 504+op←tab←origin
 dc x'0002',0,0,0,1,make←window
 org 1596+op←tab←origin
 dc x'040f',0,0,0,1,make←variable
 org 1356+op←tab←origin
 dc x'040f',x'0200',0,0,1,intern
 org 516+op←tab←origin
 dc 0,0,0,0,1,make←mark
 org 528+op←tab←origin
 dc 2,0,0,0,1,make←screen
 org 900+op←tab←origin
 dc 1,1,0,0,1,make←array
 org 1020+op←tab←origin
 dc 0,0,0,0,1,make←gnirt
 org 540+op←tab←origin
 dc x'040f',x'0402',0,0,1,insert
 org 1212+op←tab←origin
 dc x'040b',1,1,x'0402',1,insert←region
 org 1260+op←tab←origin
 dc x'040e',x'3fff',x'0402',0,1,insert←ioa
 org 552+op←tab←origin
 dc x'040e',1,0,0,1,nth
 org 1572+op←tab←origin
 dc 2,1,0,0,1,nthr
 org 564+op←tab←origin
 dc 2,0,0,0,1,location
 org 576+op←tab←origin
 dc x'040f',0,0,0,1,length
 org 588+op←tab←origin
 dc 2,1,0,0,1,set←loc
 org 600+op←tab←origin
 dc 2,1,0,0,1,add←to←loc
 org 612+op←tab←origin
 dc x'0402',1,0,0,1,delete
 org 660+op←tab←origin
 dc x'0080',2,1,0,1,set←mark
 org 672+op←tab←origin
 dc x'0080',2,0,0,1,unset←mark
 org 684+op←tab←origin
 dc x'0080',2,0,0,1,eval←mark
 org 840+op←tab←origin
 dc x'040e',1,0,0,0,handle
 org 852+op←tab←origin
 dc 0,0,0,0,0,revert
 org 1272+op←tab←origin
 dc x'040f',0,0,0,0,signal
 org 888+op←tab←origin
 dc 0,0,0,0,0,discard
 org 912+op←tab←origin
 dc x'0200',1,0,0,0,fill←vbl←array
 org 1560+op←tab←origin
 dc x'0200',x'040f',0,0,1,fill←char←array
 org 924+op←tab←origin
 dc x'0200',1,0,0,1,ar
 org 936+op←tab←origin
 dc x'3fff',x'0200',1,0,1,as
 org 1584+op←tab←origin
 dc x'0200',x'0201',0,0,1,copy←array
 org 948+op←tab←origin
 dc 2,x'040f',0,0,1,read←file
 org 960+op←tab←origin
 dc x'040f',x'040f',0,0,1,write←file
 org 1296+op←tab←origin
 dc x'040f',0,0,0,1,load
 org 984+op←tab←origin
 dc x'0020',0,0,0,1,eval
 org 996+op←tab←origin
 dc x'8000',0,0,0,1,quote
 org 1008+op←tab←origin
 dc x'0200',1,x'3fff',0,0,bind←array←cell
 org 1032+op←tab←origin
 dc x'0008',1,1,0,1,define←window
 org 1056+op←tab←origin
 dc 2,0,0,0,1,to←token←fa
 org 1068+op←tab←origin
 dc 2,0,0,0,1,to←token←fr
 org 1080+op←tab←origin
 dc 2,0,0,0,1,to←token←ba
 org 1092+op←tab←origin
 dc 2,0,0,0,1,to←token←br
 org 1104+op←tab←origin
 dc 2,0,0,0,1,over←token←fa
 org 1116+op←tab←origin
 dc 2,0,0,0,1,over←token←fr
 org 1128+op←tab←origin
 dc 2,0,0,0,1,over←token←ba
 org 1140+op←tab←origin
 dc 2,0,0,0,1,over←token←br
 org 1464+op←tab←origin
 dc 2,x'060f',0,0,1,find←first←in←fa
 org 1476+op←tab←origin
 dc 2,x'060f',0,0,1,find←first←in←fr
 org 1488+op←tab←origin
 dc 2,x'060f',0,0,1,find←first←in←ba
 org 1500+op←tab←origin
 dc 2,x'060f',0,0,1,find←first←in←br
 org 1512+op←tab←origin
 dc 2,x'060f',0,0,1,find←first←not←in←fa
 org 1524+op←tab←origin
 dc 2,x'060f',0,0,1,find←first←not←in←fr
 org 1536+op←tab←origin
 dc 2,x'060f',0,0,1,find←first←not←in←ba
 org 1548+op←tab←origin
 dc 2,x'060f',0,0,1,find←first←not←in←br
 org 1152+op←tab←origin
 dc 1,0,0,0,1,command←args
 org 1248+op←tab←origin
 dc x'040e',0,0,0,0,cline
 org 1440+op←tab←origin
 dc x'040f',0,0,0,1,call←af
 org 1368+op←tab←origin
 dc 1,0,0,0,0,restart←at
 org 1392+op←tab←origin
 dc x'0020',0,0,0,1,get←pname
 org 1452+op←tab←origin
 dc x'040f',1,0,0,1,get←hpos
 org 1608+op←tab←origin
 dc 2,0,0,0,1,make←read←only
 org 1620+op←tab←origin
 dc x'0020',0,0,0,1,get←documentation
 org 1680+op←tab←origin
 dc 0,0,0,0,0,0

          incl inst
          incl control
          incl file

          end

↑L 
     Listing of >s>langs>sine>rh.sysin  12/30/79 17:27:03

          incl defuns
          extrn     swap←in   *** not used ***
          extrd     linkage$no←display  horrible hacks for tty's
          incl data←types

          pc   0
          org  0
          incl static
          pc   1

          entry     real←make←screen,real←display,real←force←display
          entry     real←print,real←display←screen,get←line,real←get←hpos
          entry     backup

          extrn     $allocate,$get←init,$getr←init,$make←variable,$make←mark
          extrn     $set←mark←reg,$eval←mark←reg,$tyi
          extrn     iocs$order,iocs$put←chars,$sfd

*    1 screen based,
*         2 next ptr,              /* next screen */
*         2 buffer ptr,            /* could be a string */
*         2 line←on←screen fixed,  /* physical starting line */
*         2 last←line fixed;       /* (number←of←lines - 1) * 4 */
*         2 first←mod fixed,       /* line containing start←mod */
*         2 displayed fixed,       /* flag set when display is started */
*         2 force←display bit(32), /* force redisplay on these lines */
*         2 lines(n) ptr;          /* mark for each line */

*    1 lines static,
*         2 screen(25) ptr,        /* ptr to screen this line is part of */
*         2 next(25) ptr;          /* ptr to a list of previous screens */

*         This little routine updates the display of the screen.

*         It goes over each line and updates the screen that line
*         is in.  If the point in not visible then a recenter is
*         performed.  Otherwise the pt is fixed on the screen and
*         the start←mod and end←mod markers are examined to determine
*         what stuff to redisplay.  The redisplay process only up
*         dates the line markersbut does no actual IO.  This is done
*         in a second simple pass.  The end of the current screen
*         is defined by a change in the window ptrs.  After all the
*         screens are updated and redisplayed the start←mod and end←mod
*         markers are reset to show no modification.

line           equ  first←free+5
screen         equ  first←free+6

*    make←screen a,b,c  Takes a buffer "a" and puts it on the screen
*    starting at physical line number "b" and in a window "c" lines long.

real←make←screen    equ  *
          save
          lhi  5,screen←size
          ahi  5,num←of←lines*4              max of 24 lines/screen
          bal  link,$allocate
          lr   screen,rv
          oi   screen,screen←bits
          l    source,op1(ops)
          st   source,screen.buffer(screen)
          l    temp,screen←chain(ls)
          st   temp,screen.next(screen)      thread it on the list
          st   screen,screen←chain(ls)
          lis  temp,0
          lhi  t1,num←of←lines*4-4
ms.zap    st   temp,screen.start(screen,t1)  for the gc
          sis  t1,4
          bnms ms.zap

*         check to see if initialization is needed

          la   temp,current←screen←string
          st   temp,op1(ops)
          bal  link,$make←variable
          st   rv,current←screen←ptr(ls)

ms.no←init     equ  *
          lis  index,0
          l    rv,buffer.start←mod(source)
          bnzs ms.is←start
          bal  link,$make←mark
          st   rv,buffer.start←mod(source)
          bal  link,$set←mark←reg                 install in marker chain
ms.is←start    equ  *
          l    temp,buffer.top(source)
          st   temp,marker.mv(rv)
          l    rv,buffer.end←mod(source)
          bnzs ms.is←end
          bal  link,$make←mark
          st   rv,buffer.end←mod(source)
          bal  link,$set←mark←reg
ms.is←end lis  temp,0
          st   temp,marker.mv(rv)
          st   temp,screen.last←top(screen)
          sth  temp,screen.displayed(screen)
          lcs  temp,1
          st   temp,screen.force←display(screen)
          st   temp,screen.emptyp(screen)

          lhi  line,num←of←lines*4-4
          lis  index,0
ms.loop   bal  link,$make←mark
          st   rv,screen.start(line,screen)
          bal  link,$set←mark←reg            uses source,rv,index
          sis  line,4
          bnms ms.loop

          lr   rv,screen
          b    popj

*    This makes sure a screen will be redisplayed

real←display←screen equ  *
* screen equ t2
          l    screen,op1(ops)                    get screen to display
          l    t1,op3(ops)                        get length of screen
          slls t1,2
          l    t3,op2(ops)                        get place to put it

          lr   screen,screen                      save in screen if ↑clearing
          bzs  ds.no←set
          sth  t1,screen.last←line(screen)
          sth  t3,screen.line←on←screen(screen)

ds.no←set sis  t3,1
          slls t3,2
          la   rv,lines.screen(ls,t3)
          ar   t3,t1                              make abs. line #
          srls t3,2
ds.loop   sis  t3,1
          sis  t1,4
          bmr  link
          cl   screen,0(rv,t1)
          bes  ds.loop
          sbt  t3,bashed←lines
          st   screen,0(rv,t1)
          bs   ds.loop

*    This just forces the redisplay of a window.

real←force←display  equ  *
          l    screen,op1(ops)
          l    temp,op2(ops)                 get line for center or -1
          st   temp,screen.force←display(screen)
          br   link

*    This routine which makes sure that all windows on the screen are
*    correct.

real←display   equ  *
          save

          lr   rv,2      ultra paranoia since 2 may be important
          bal  link,linkage$no←display
          lb   0,0(2)
          lr   2,rv
          thi  0,x'80'
          bnz  popj

          l    rv,linel←ptr(ls)
          l    temp,variable.value(rv)
          sth  temp,linel

          lis  line,0                   start at first line
disp.next l    screen,lines.screen(line,ls)
          bzs  disp.inc←line
          bal  link,scan←for←damage
disp.inc←line  equ  *
          lh   temp,breakp(ls)
          bnz  popj                     if break hit punt
          bal  link,show←line
          ais  line,4
          clhi line,num←of←lines*4
          bnls reset←screen
          cl   screen,lines.screen(line,ls)
          bes  disp.inc←line            another line on same screen
          b    disp.next                new and different screen

     instruction    ←reset←screen
reset←screen   l    screen,screen←chain(ls)
disp.reset←l   lh   temp,screen.displayed(screen)
          bz   reset←next
reset←it  l    source,screen.buffer(screen)  reset the modification markers
          l    rv,buffer.start←mod(source)
          l    temp,buffer.top(source)
          st   temp,marker.mv(rv)
          l    rv,buffer.end←mod(source)
          lis  temp,0
          st   temp,marker.mv(rv)
          sth  temp,screen.displayed(screen)
          st   temp,screen.force←display(screen)
reset←next     l    screen,screen.next(screen)
          bnz  disp.reset←l

          l    t1,current←screen←ptr(ls)
          l    screen,variable.value(t1)
          l    source,screen.buffer(screen)
          l    index,buffer.location(source)
          make←absolute←bufptr     index,source
          st   index,save.index
          lh   line,screen.current←line(screen)
          st   line,save.line
          lis  index,0
          bal  link,$get←init
          lis  colno,1
          l    index,screen.start(line,screen)
          l    index,marker.mv(index)
disp.find←pos  equ  *
          cl   index,save.index
          bnls disp.position
          bal  link,assemble←char
          bs   disp.find←pos
disp.position  equ  *
          clhi colno,1
          bnes disp.no←next←line
          l    line,save.line
          l    get,screen.start(line,screen)
          cl   index,marker.mv(get)
          bes  disp.no←next←line
          ais  line,4                        it fell into the next line
          st   line,save.line
disp.no←next←line   equ  *
          lhi  char,c'xy'                    position to right place
          sth  char,dispop(ls)
          sth  colno,x←cord(ls)
          l    char,save.line
          srls char,2
          ah   char,screen.line←on←screen(screen)
          sth  char,y←cord(ls)

          la   char,user←output(ls)          setup for call to order
          st   char,arg1p(sp)
          la   char,curpos←string
          st   char,arg2p(sp)
          la   char,pos←struc←ptr(ls)
          st   char,arg3p(sp)
          la   char,code(ls)
          st   char,arg4p(sp)
          lhi  char,20
          st   char,alist←size(sp)
          la   ap,alist(sp)

          save
          bal  link,iocs$order
          restore

          b    popj

     instruction    ←scan←for←damage
scan←for←damage equ *

          lh   temp,screen.displayed(screen)      already done
          bnzr link
          lis  temp,1
          sth  temp,screen.displayed(screen)

          save
          l    source,screen.buffer(screen)
          lis  index,0
          bal  link,$get←init                     make sure it's swapped in.
          lis  temp,8
          st   temp,alist←size(sp)
          st   screen,arg1p(sp)
          la   ap,alist(sp)
          st   stack,state.sp(ls)                 so it can call back in.
          bal  link,$sfd
          b    popj

colno     equ  first←free+7                  So put←ptr and sink can be used

          pc   0
          org  0
line.start     ds   4
line.end       ds   4
line.empty     ds   1
          pc   1

get←line  equ  *
          .ent 0
          l    stack,state.sp(ls)

*    This routine is called from sfd.pl1 with current←buffer,place,bob,line.
*         current←buffer is the buffer that is being scaned.
*         place is the ptr to the beginning of the line
*         bob if a bit one vbl which is whether the line falls off the end.
*         line is a structure defined above.

*    This routine reads characters using "get" until it gets a full line.
*    It returns with reg 0 (char ,temp) set to -1 if it is at the end
*    of the buffer.

          save
          l    rv,4(ap)
          l    source,0(rv)
          lis  index,0
          bal  link,$get←init

          l    rv,8(ap)
          l    index,0(rv)
          l    t2,16(ap)                          get ptr to line
          st   index,line.start(t2)
          s    index,buffer.base(source)          get compatable form
          lis  colno,1

          lr   rv,index
          cl   index,buffer.gap←start(source)
          bl   gl.loop                       ↑empty
          bps  gl.emptyp
          l    rv,buffer.gap←end(source)
gl.emptyp l    temp,buffer.top(source)
          sr   temp,rv
          bnzs gl.loop                       room in upper section
          lcs  temp,1                        empty = "1"b
          stb  temp,line.empty(t2)
          l    rv,12(ap)
          stb  temp,0(rv)                    empty implied bob
          b    gl.real←return

gl.loop   st   index,save.index              save incase we have to backup
          bal  link,assemble←char
          lr   char,char
          bm   gl.return
          clhi char,x'0d'                    CR
          be   gl.not←bob←return
gl.check←colno equ  *
          clh  colno,linel
          bls  gl.loop                       still more room.
          bes  gl.is←it←too←long
          l    index,save.index              fell off end (back up one)
          bs   gl.not←bob←return
gl.is←it←too←long   equ  *                   check next char
          st   index,save.index
          balr link,get
          lhi  link,0                        do nothing
          clhi char,x'0d'
          bes  gl.not←bob←return
          l    index,save.index              lne is really too long
gl.not←bob←return   equ  *
          lis  t1,0
          bs   gl.return

gl.bob←return  equ  *
          lcs  t1,1                          bob = "1"b
gl.return equ  *
          l    rv,12(ap)
          stb  t1,0(rv)                      set up bob
          l    rv,16(ap)
          a    index,buffer.base(source)
          st   index,line.end(rv)
          l    t1,8(ap)
          st   index,0(t1)                   bump place to new value
          lis  temp,0                        ↑empty
          stb  temp,line.empty(rv)

gl.real←return equ  *
          restore
          .rtn

backup    .ent 0
          l    stack,state.sp(ls)

          l    1,4(ap)
          l    source,0(1)                   get buffer
          l    index,buffer.location(source)
          bal  link,$getr←init
          l    1,12(ap)
          lh   t1,0(1)                       get number of lines
          lr   t2,t1
          mh   t2,linel(ls)                  max number of chars

b.loop    balr link,get
          lcs  t1,1
          bs   b.done
          sis  t2,1
          bms  b.no←set
          clhi char,13                       count crs too.
          bnes b.loop
          sis  t1,1
          bnms b.loop

b.no←set  lis  t1,0                          not to beginning of buffer.
b.done    ais  index,1
          a    index,buffer.base(source)
          l    1,8(ap)
          st   index,0(1)                    return new ptr
          l    1,16(ap)
          stb  t1,0(1)                       return tob flag

          .rtn


*    This gets a char and increments colno by the approptiate amount

assemble←char  equ  *
          lr   rv,link
          balr link,get
          lr   link,rv
          br   link                          if error (fell off end)
          lr   link,rv                       returns here if get a char
          nhi  char,x'7f'
          clhi char,x'0d'                    CR: resets colno
          bnes ac.not←cr
          st   colno,save.colno              save this for get←line
          lis  colno,1
          br   link
ac.not←cr clhi char,x'09'                    Tab
          bnes ac.reg
          lr   type,colno                    uses type,sink which are cont.
          sis  type,1
          dh   type,five                     remander->type,quotient->sink
          mh   sink,five
          ais  sink,6
          lr   colno,sink
          br   link
five      dc   5

ac.reg    lr   rv,char
          slls rv,1
          ah   colno,size←table(rv)
          br   link

*    This routine check the current line and checks
*    the damage switch.  If the switch is set the line is assembled
*    and output at the appropriate place on the screen.  If only the
*    redisplay switch is set then that line is output from the
*    start←mod position to the end of the line.

     instruction    ←show←line

show←line      equ *
          lr   screen,screen
          bzr  link                          we get some real weirdos!
          save

          l    source,screen.buffer(screen)
          lr   rv,line
          lh   temp,screen.line←on←screen(screen)
          sis  temp,1
          slls temp,2
          sr   line,temp                     get line relative to screen
          st   line,save.line

          srls rv,2                          test real line number
          rbt  rv,bashed←lines               clear and test
          bnz  sl.stuff←it

          clh  line,screen.first←mod(screen)
          bes  sl.start←mod                  do this line.

          tbt  rv,screen.force←display(screen)
          bz   popj
          b    sl.stuff←it

*    This means output line from start←mod to end else same as negative flag

sl.start←mod   equ  *
          lis  index,0
          bal  link,$get←init

          l    rv,screen.start(line,screen)
          l    index,marker.mv(rv)
          lis  colno,1
          l    rv,buffer.start←mod(source)        go to sm before printing
          l    type,marker.mv(rv)
          st   type,save.index
sl.find←sm     equ  *
          cl   index,save.index                   stop at start←mod
          bnl  sl.put←it
          bal  link,assemble←char                 this bashes rv,type,line
          clhi char,x'0d'
          bnes sl.find←sm
          lis  temp,4
          ahm  temp,screen.first←mod(screen)      sm is really on next line
          b    popj                               punt if sm is at end of line

sl.stuff←it    equ  *
          lis  index,0
          bal  link,$get←init
          l    rv,screen.start(line,screen)
          l    index,marker.mv(rv)
          lis  colno,1
sl.put←it la   type,io←buffer(sp)                 running low on regs
          l    line,save.line
          l    rv,screen.start+4(line,screen)
sl.stuff←l     equ  *
          cl   index,marker.mv(rv)                are we done yet?
          bnls sl.output
          balr link,get
          b    error11                            can't report this as an error
*         bal  link,error                         shouldn't run out of chars
error11   equ  *
          clhi char,x'0d'
          bes  sl.output
          stb  char,0(type)
          ais  type,1
          bs   sl.stuff←l

sl.output lhi  char,c'xy'                    position to right place
          sth  char,dispop(ls)
          sth  colno,x←cord(ls)
          lr   char,line
          srls char,2
          ah   char,screen.line←on←screen(screen)
          sth  char,y←cord(ls)

          la   char,user←output(ls)          setup for call to order
          st   char,arg1p(sp)
          la   char,curpos←string
          st   char,arg2p(sp)
          la   char,pos←struc←ptr(ls)
          st   char,arg3p(sp)
          la   char,code(ls)
          st   char,arg4p(sp)
          lhi  char,20
          st   char,alist←size(sp)
          la   ap,alist(sp)

          save
          bal  link,iocs$order
*
          lhi  char,c'cl'                    clear the line too
          sth  char,dispop(ls)
          bal  link,iocs$order
*
          lr   char,type                     calculate line size
          shi  char,io←buffer(sp)
          st   char,io←buffer←len(sp)
          la   char,io←buffer←ptr(sp)        set up for call to put←chars
          st   char,arg2p(sp)
          la   char,io←buffer←len(sp)
          st   char,arg3p(sp)
          bal  link,iocs$put←chars
          restore

popj      restore
          br   link

real←get←hpos  equ  *
          save
          l    source,op1(ops)
          l    index,op2(ops)
          bal  link,$getr←init
gh.back←loop   equ  *
          balr link,get
          b    gh.start←here
          clhi char,13
          bnes gh.back←loop
          make←virtual←bufptr index,source
gh.start←here  equ  *
          ais  index,1                  skip the CR.
          l    t1,op2(ops)
          make←absolute←bufptr     t1,source
          st   t1,save.index
          l    source,op1(ops)
          lis  colno,1
          bal  link,$get←init

gh.find←pos    equ  *
          cl   index,save.index
          bnls gh.done
          bal  link,assemble←char
          lr   char,char
          bnms gh.find←pos
gh.done   lr   rv,colno
          b    popj

real←print     equ  *
          st   rv,save.index            flag saying whether to do a cl
          save
          l    rv,linel←ptr(ls)
          l    temp,variable.value(rv)
          sth  temp,linel

          l    source,op1(ops)
          lis  index,0                       start at the beginning
          bal  link,$get←init
          l    colno,op2(ops)
          l    temp,op3(ops)
          st   temp,save.line
print.line←loop     equ  *
          l    temp,save.line
          bal  link,position                 go there

          la   put←ptr,io←buffer(sp)
print.loop     equ  *
          bal  link,assemble←char
          lr   char,char
          bnms print.check←endings
          lis  source,0
          b    print.put
print.check←endings equ  *
          clhi char,x'0d'
          be   print.put
*         clhi char,x'0a'
*         be   print.put
          clh  colno,linel
          bls  print.stuff←it
          stb  char,0(put←ptr)
          ais  put←ptr,1
          lis  colno,1
          b    print.put

print.stuff←it equ  *
          stb  char,0(put←ptr)
          ais  put←ptr,1
          b    print.loop

print.put l    temp,op4(ops)            do more←processing?
          bz   print.real←put
          l    temp,save.line
          clhi temp,24
          bl   print.real←put
          sis  temp,1
          bms  p.punt1
          sbt  temp,bashed←lines
p.punt1   la   temp,user←input(ls)
          st   temp,arg1p(sp)
          la   temp,io←buffer←ptr(sp)
          st   temp,arg2p(sp)
          la   temp,more←string
          st   temp,io←buffer←ptr(sp)
          la   temp,more←string←length
          st   temp,arg3p(sp)
          la   temp,code(ls)
          st   temp,arg4p(sp)
          lhi  temp,20
          st   temp,alist←size(sp)
          la   ap,alist(sp)
          save
          bal  link,iocs$put←chars
          la   temp,io←buffer(sp)
          st   temp,io←buffer←ptr(sp)
          bal  link,$tyi                     wait for him to be ready
          restore
          clhi rv,x'20'                      did he type a space?
          bne  popj                          if no then punt the rest
          lis  temp,1
          st   temp,save.line
          bal  link,position

print.real←put equ  *
          l    temp,save.line
          sis  temp,1
          bms  p.punt
          sbt  temp,bashed←lines

p.punt    la   temp,user←output(ls)
          st   temp,arg1p(sp)
          la   temp,io←buffer←ptr(sp)
          st   temp,arg2p(sp)
          la   temp,io←buffer←len(sp)
          st   temp,arg3p(sp)
          la   temp,code(ls)
          st   temp,arg4p(sp)
          lhi  temp,20
          st   temp,alist←size(sp)
          la   ap,alist(sp)
          shi  put←ptr,io←buffer(sp)    calculate length
          st   put←ptr,io←buffer←len(sp)
          save
          bal  link,iocs$put←chars
          restore
          l    temp,save.line
          ais  temp,1                   next line
          st   temp,save.line
          lr   source,source
          bnz  print.line←loop          not done yet
          lis  rv,0
          b    popj

          align     4
more←string    dc   c'--more--'
more←string←length  dac  8

position  equ  *                             x-cord in colno, y-cord in temp
          lr   colno,colno
          bz   p.nc
          lr   temp,temp
          bzs  p.co
          lhi  rv,c'xy'                 position to right place
          sth  rv,dispop(ls)
          sth  colno,x←cord(ls)
          sth  temp,y←cord(ls)
          b    p.doit

p.co      lhi  rv,c'sc'
          sth  rv,dispop(ls)
          sth  colno,x←cord(ls)
          bs   p.doit

p.nc      lr   temp,temp
          bzr  link                     no positioning to do.
          lhi  rv,c'sl'
          sth  rv,dispop(ls)
          sth  temp,x←cord(ls)

p.doit    la   char,user←output(ls)     setup for call to order
          st   char,arg1p(sp)
          la   char,curpos←string
          st   char,arg2p(sp)
          la   char,pos←struc←ptr(ls)
          st   char,arg3p(sp)
          la   char,code(ls)
          st   char,arg4p(sp)
          lhi  char,20
          st   char,alist←size(sp)
          la   ap,alist(sp)

          save
          bal  link,iocs$order
          l    temp,save.index
          bzs  posn.no←clear
          lhi  temp,c'cl'
          sth  temp,dispop(ls)
          bal  link,iocs$order
posn.no←clear  equ  *
          restore
          br   link

size←table     equ  *
          dc   2,2,2,2,2,2,2,0,-1,0,2,2,2,0,2,2
          dc   2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2
          dc   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
          dc   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
          dc   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
          dc   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
          dc   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
          dc   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
          dc   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
          dc   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0

current←screen←string    dc   14,c'current←screen'

          pc   7

curpos←string  dc   c'cur←pos '

          align 4
bashed←lines   dac  0

linel          dc   80

          align 4

save.count     dac  0
save.stack     dac  0
save.screen    dac  0
save.line      dac  0
save.index     dac  0
save.colno     dac  0

          end
↑L 
     Listing of >s>langs>sine>sine.asm  12/30/79 17:28:00

(variable hack←window)
(variable linel)
(variable screen←length)
(variable current←screen)
(variable char)
(variable buf)
(variable mark)
(variable dispatch←table)
(variable echo←buf)
(variable echo←area)
(variable echo←mark)
(variable buffer←stack)
(variable search←string←hack)
(variable saved←search←string)

(defun top←level ( &aux main←buffer screen )
     (store (cons (store (make←buffer) main←buffer) 0) buffer←stack)
     (store (make←marker) mark)
     (store (make←screen main←buffer 1 21) screen)
     (store 80 linel)
     (store 21 screen←length)
     (store (make←array 32 128) dispatch←table)   ; make a FW array for dispatching
     (store (make←screen (store (make←buffer) echo←buf) 24 1) echo←area)
     (store (make←marker) echo←mark)
     (store (make←window main←buffer) hack←window)
     (store (make←window echo←buf) search←string←hack)
     (store (make←gnirt) saved←search←string)

     (fill←vbl←array dispatch←table 128
do←set←mark beginning←of←line do←back do←return        ;↑@
do←delete end←of←line do←forward print←test            ;↑D
do←back insert←char pp←buffers kill←line               ;↑H
full←redisplay carriage←return next←line insert←char   ;↑L
previous←line insert←char input←file string←search     ;↑P
top←of←buffer insert←char next←page output←file        ;↑T
insert←char illegal←char bottom←of←buffer alt←mode     ;↑X
insert←char insert←char insert←char insert←char        
insert←char insert←char insert←char insert←char
insert←char insert←char insert←char insert←char
insert←char insert←char insert←char insert←char
insert←char insert←char insert←char insert←char
insert←char insert←char insert←char insert←char
insert←char insert←char insert←char insert←char
insert←char insert←char insert←char insert←char
backward←token insert←char forward←token insert←char   ;&lt;
insert←char insert←char insert←char insert←char
insert←char insert←char insert←char insert←char
insert←char insert←char insert←char insert←char
insert←char insert←char insert←char insert←char
insert←char insert←char insert←char insert←char
insert←char insert←char insert←char insert←char
insert←char insert←char insert←char insert←char
insert←char insert←char insert←char insert←char
insert←char insert←char insert←char insert←char
insert←char insert←char insert←char insert←char
insert←char insert←char insert←char insert←char
insert←char insert←char insert←char insert←char
insert←char insert←char insert←char insert←char
insert←char insert←char insert←char insert←char
insert←char insert←char insert←char insert←char
insert←char insert←char insert←char do←rubout
)
reader←loop
     (reader main←buffer screen)
     (return)
     (goto reader←loop))

(defun reader (buf current←screen)
     (full←redisplay)
     (errset "↑opcode "                 ;this is just a hack to non-local goto
             (loop  (ifne (tyis) 0 just←read)
                    (display)
              just←read
                    (call←vbl (ar dispatch←table (store (tyi) char)) 0)
                    (goto loop))
             ((return))))

(defun forward←token ()
     (set←loc buf (over←token←fa buf)))

(defun backward←token ()
     (set←loc buf (over←token←ba buf)))

(defun print←test ()
     (define←window hack←window (location buf) (add (location buf) 5))
     (print hack←window 70 5)
     (tyi)
     (return))

(defun insert←char ()
     (insert char buf))

(defun carriage←return ()
     (insert 13 buf))

(defun alt←mode ()
     (insert 27 buf))

(defun illegal←char ()
     (insert 1 current←screen))    ;should blow out with a bad type error

(defun do←set←mark ()
     (set←mark mark buf (location buf)))

(defun do←delete ()
     (delete buf 1))

(defun do←rubout ()
     (delete buf -1))

(defun next←line ( &aux offset )
     (store (sub -1 (iferror (rsearchr buf 13)
                             (sub -1 (location buf)))) offset)
     (set←loc buf (iferror (search buf 13) (return)))
     (add←to←loc buf (min offset
                          (sub (iferror (searchr buf 13)
                                        (add (sub (length buf)
                                                  (location buf)) 1)) 1))))

(defun next←page ( &aux i )
     (store (sub screen←length 2) i)
next←page←loop
     (ife i 0 quit)
     (next←line)
     (store (sub i 1) i)
     (goto next←page←loop)
quit (force←display current←screen 1))

(defun previous←line ( &aux offset )
     (store (sub -1 (iferror (rsearchr buf 13) (return))) offset)
     (add←to←loc buf (sub -1 offset))
     (set←loc buf (iferror (add 1 (rsearch buf 13)) (push 0)))
     (add←to←loc buf (min offset (sub (searchr buf 13) 1))))

(defun pp←buffers (&aux new←buf)
     (ife (tyi) 0 pop)
     (store (cons (store (make←buffer) new←buf) buffer←stack) buffer←stack)
     (store new←buf buf)
     (return)
pop  (store (cdr buffer←stack) buffer←stack)
     (store (car buffer←stack) buf))

(defun beginning←of←line ()
     (set←loc buf (add (iferror (rsearch buf 13) (push -1)) 1)))

(defun end←of←line ()
     (set←loc buf (sub (search buf 13) 1)))

(defun kill←line ( &aux ll )
     (store (sub (searchr buf 13) 1) ll)
     (delete buf (max 1 ll)))

(defun do←return ()                ;the reader handles II and returns
     (number 0))

(defun full←redisplay ()
     (force←display current←screen -1))

(defun do←switch←pm ( &aux temp←loc )
     (store (location buf) temp←loc)
     (set←loc buf (eval←mark mark buf))
     (set←mark mark buf temp←loc))

(defun do←back ()
     (add←to←loc buf -1))

(defun do←forward ()
     (add←to←loc buf 1))

(defun input←file ()
     (read←file buf (read←line ifn 13))
     (full←redisplay)
     (return)
ifn  (string "input file name: "))

(defun output←file ()
     (write←file buf (read←line ofn 13))
     (return)
ofn  (string "output file name: "))

(defun top←of←buffer ()
     (set←loc buf 0))

(defun bottom←of←buffer ()
     (set←loc buf (length buf)))

(defun string←search ( &aux ss )
;    (store do←return alt←mode)
;    (set←loc echo←buf 0)
;    (delete echo←buf (length echo←buf))
;    (reader echo←buf echo←area)
     (store (read←line ssp 27) ss)
     (ife (length ss) 0 do←search)
; he gave us a new search string
     (delete saved←search←string (length saved←search←string))
     (insert ss saved←search←string)
do←search
     (set←loc buf (iferror (search buf saved←search←string) (goto sfailed)))
     (return)
sfailed
     (print fsp 20 24)
     (return)
fsp  (string "Search Failed")
ssp  (string "Search String: "))

;    useful routines

(defun read←line (prompt terminator )
     (bind←array←cell←to dispatch←table terminator (quote do←return))
     (set←loc echo←buf 0)
     (delete echo←buf (length echo←buf))
     (insert prompt echo←buf)
     (set←mark echo←mark echo←buf (length echo←buf))

     (reader echo←buf echo←area)
     (push (define←window search←string←hack
                          (eval←mark echo←mark echo←buf)
                          (length echo←buf))))

↑L 
     Listing of >s>langs>sine>foo.asm   12/30/79 17:26:37

(variable white←space)

(defun bar ()
     (fill←char←array (store (make←array 1 128) white←space) "   
"))

(defun foo ()
     (delete tg 10000)
     (print←msg (insert←ioa "char: ↑2w" (nthr current←buffer 0) tg) 0)
     (set←loc current←buffer (find←first←in←fa current←buffer white←space)))

↑L 
     Listing of >s>langs>sine>tgc.asm   12/30/79 17:26:33

(variable foo)
(variable a)
(variable b)
(variable d)
(variable nonlocal)
(variable current←screen)
(variable buf)
(variable array)

(defun top←level ( &aux m s)
     (store (make←array 32 10) array)
;    (store (insert "foo bar" (make←gnirt)) d)
     (as (store (make←buffer) buf) array 1)
     (insert "this is a test" buf)
     (store (make←screen buf 1 10) current←screen)
     (display)
     (store (cons 0 (insert "foo bar" (make←gnirt))) d)
     (load "nonlocal.sine")

loop (cons 1 2)
;    (print d 1 1 0)
;    (print (nth buf (eval←mark m buf)) 1 2 0)
     (print (cdr d) 1 1 0)
     (errset "foob    " ((signal "foob")) ())
     (nonlocal)
     (store (tyi) foo)
     (ift (eq foo 113) return)
     (bar foo 0)
     (insert←ioa "↑i done
" foo (ar array 1))
     (display)
     (goto loop)
return
     (restart←at loop)
     (return)
     (goto loop))

(defun bar (a d &aux i)
     (for i 1 a (make←gnirt))
;    (print←clearing "Done" 1 a 0)
     )
↑L 
     Listing of >s>langs>sine>mgc.asm   12/30/79 17:26:33

(variable argument)

(defun mgc ( &aux i )
     (for i 1 argument (cons 7 7))
     (store 0 argument))
↑L 
     Listing of >s>langs>sine>file.incl.sysin     08/13/80 12:28:01


*         dcl $pl1←load entry(structure,ptr);
*         call $pl1←load (state,code←ptr);

          extrn     $pl1←load

     instruction    load
          save
          l    temp,op1(ops)
          st   temp,op2(ops)
          lcs  t1,1                     hcs$initiate only! (-1)
          bal  link,initiate
          l    rv,code
          bm   popj
          la   temp,state
          st   temp,arg1p(sp)
          la   temp,segptr(sp)
          st   temp,arg2p(sp)
          lhi  temp,12
          st   temp,alist←size(sp)
          la   ap,alist(sp)
          st   stack,state.sp           insure consistancy
          bal  link,$pl1←load           fas←load the program
          l    rv,code
          b    popj

     instruction    read←file
          save
          lcs  t1,1                     read←only no append/truncate
          bal  link,initiate
          l    rv,code
          bnms rf.ok
f.error   lcs  temp,1
          st   temp,error←register
          b    popj
rf.ok     st   rv,in.save.flag
          l    source,op1(ops)
          bal  link,swap←in
          l    t1,buffer.base(source)
          l    t2,segptr(sp)            get ptr to segment
          la   ap,alist(sp)
          la   link,segptr(sp)
          st   link,arg1p(sp)
          la   link,segsize(sp)
          st   link,arg2p(sp)
          lis  link,12
          st   link,alist←size(sp)
          save
          bal  link,hcs$get←bit←count
          restore
          l    t3,segsize(sp)
          srls t3,3
rf.loop   sis  t3,1
          bms  rf.done
          lb   char,0(t2)
          stb  char,0(t1)
          ais  t2,1
          ais  t1,1
          bs   rf.loop

rf.done   l    rv,buffer.marker←chain(source)     blast out all the markers
          bzs  rf.done←zapping
          lis  temp,0
rf.zap←loop    equ  *
          st   temp,marker.mv(rv)
          l    rv,marker.next(rv)
          bnzs rf.zap←loop
rf.done←zapping     equ  *
          lis  temp,0
          st   temp,buffer.location(source)
          l    t3,segsize(sp)
          srls t3,3
          st   t3,buffer.gap←start(source)
          lhi  temp,500(t3)                  leave some room for expansion
          st   temp,buffer.gap←end(source)
          st   temp,buffer.top(source)

          lis  temp,8
          st   temp,alist←size(sp)
          la   ap,alist(sp)
          bal  link,hcs$terminate

f.win     l    rv,in.save.flag
          lis  temp,0
          st   temp,error←register
          b    popj

     instruction    write←file
          save
          l    source,op1(ops)               figure out correct size!
          bal  link,get←length
*
          ahi  rv,2047
          srls rv,11
          lr   t1,rv
*
          bal  link,initiate
          l    rv,code
          bm   f.error
          st   rv,in.save.flag
          l    source,op1(ops)
          lis  index,0
          bal  link,get←init
          l    t1,segptr(sp)
wf.loop   balr link,get
          b    wf.done
          stb  char,0(t1)
          ais  t1,1
          bs   wf.loop
wf.done   l    source,op1(ops)
          bal  link,get←length
          slls rv,3
          st   rv,segsize(sp)
          la   link,segptr(sp)
          st   link,arg1p(sp)
          la   link,segsize(sp)
          st   link,arg2p(sp)
          lis  link,12
          st   link,alist←size(sp)
          la   ap,alist(sp)
          bal  link,hcs$set←bit←count
          lis  link,8
          st   link,alist(sp)
          bal  link,hcs$terminate
          b    f.win

initiate  save
          st   t1,in.save.flag                    save flag
          l    source,op2(ops)                    get file name
          lis  index,0
          bal  link,get←init
          la   t1,dname.chars(sp)
in.loop   balr link,get
          b    in.got←name
          stb  char,0(t1)
          ais  t1,1
          bs   in.loop
in.got←name    equ  *
          shi  t1,dname.chars(sp)
          st   t1,dname.length(sp)
          la   temp,dname(sp)
          st   temp,arg1p(sp)
          st   temp,arg2p(sp)
          la   temp,ename(sp)
          st   temp,arg3p(sp)
          la   temp,code
          st   temp,arg4p(sp)
          lhi  temp,20
          st   temp,alist←size(sp)
          la   ap,alist(sp)
          bal  link,scs$expand←path
          l    temp,code
          bm   popj
          la   temp,ename(sp)
          st   temp,arg2p(sp)

          l    temp,in.save.flag                  check flag
          bm   in.in

          la   temp,code
          st   temp,arg3p(sp)
          lhi  temp,16
          st   temp,alist←size(sp)
          bal  link,hcs$append←seg
          la   temp,segptr(sp)
          st   temp,arg3p(sp)
          l    temp,in.save.flag
          sth  temp,segptr(sp)          fixed bin length to truncate to
          lhi  temp,20
          st   temp,alist←size(sp)
          bal  link,hcs$truncate←file
          l    temp,code
          bnms in.in
          clhi temp,-31                           we know we can't trunc. links
          bne  popj

in.in     la   temp,segptr(sp)
          st   temp,arg5p(sp)
          la   temp,code
          st   temp,arg6p(sp)
          lis  temp,0
          st   temp,arg7p(sp)
          la   temp,arg7p(sp)
          st   temp,arg3p(sp)                     null ref name
          lcs  temp,0
          st   temp,arg8p(sp)
          la   temp,arg8p(sp)
          st   temp,arg4p(sp)                     "0"b return the ptr
          lhi  temp,28
          st   temp,alist←size(sp)
          bal  link,hcs$initiate←w←options
          b    popj

↑L 
     Listing of >s>langs>sine>disp.incl.sysin     12/30/79 17:28:05

*    1 screen based,
*         2 next ptr,              /* next screen */
*         2 buffer ptr,            /* could be a string */
*         2 line←on←screen fixed,  /* physical starting line */
*         2 last←line fixed;       /* (number←of←lines - 1) * 4 */
*         2 first←mod fixed,       /* line containing start←mod */
*         2 displayed fixed,       /* flag set when display is started */
*         2 force←display bit(32), /* force redisplay on these lines */
*         2 lines(n) ptr;          /* mark for each line */

*    1 lines static,
*         2 screen(25) ptr,        /* ptr to screen this line is part of */
*         2 next(25) ptr;          /* ptr to a list of previous screens */

*         This little routine updates the display of the screen.

*         It goes over each line and updates the screen that line
*         is in.  If the point in not visible then a recenter is
*         performed.  Otherwise the pt is fixed on the screen and
*         the start←mod and end←mod markers are examined to determine
*         what stuff to redisplay.  The redisplay process only up
*         dates the line markersbut does no actual IO.  This is done
*         in a second simple pass.  The end of the current screen
*         is defined by a change in the window ptrs.  After all the
*         screens are updated and redisplayed the start←mod and end←mod
*         markers are reset to show no modification.


line           equ  first←free+5
screen         equ  first←free+6

*    make←screen a,b,c  Takes a buffer "a" and puts it on the screen
*    starting at physical line number "b" and in a window "c" lines long.

     instruction    make←screen
          save
          lhi  5,screen←size
          l    type,op3(ops)
          slls type,2
          ar   5,type                   room for the lines too
          ais  5,4                      and one extra
          bal  link,allocate
          lr   screen,rv
          oi   screen,screen←bits
          l    source,op1(ops)
          st   source,screen.buffer(screen)

*         check to see if initialization is needed

          l    temp,linel←ptr
          bnz  ms.no←init
          la   temp,linel←string
          st   temp,op1(ops)
          bal  link,make←variable
          lhi  temp,80                  set up the default value
          st   temp,variable.value(rv)
          st   rv,linel←ptr
          la   temp,current←screen←string
          st   temp,op1(ops)
          bal  link,make←variable
          st   rv,current←screen←ptr

ms.no←init     equ  *
          lis  index,0
          l    rv,buffer.start←mod(source)
          bnzs ms.is←start
          bal  link,make←marker
          st   rv,buffer.start←mod(source)
          bal  link,set←mark←reg                  install in marker chain
ms.is←start    equ  *
          l    temp,buffer.top(source)
          st   temp,marker.mv(rv)
          l    rv,buffer.end←mod(source)
          bnzs ms.is←end
          bal  link,make←marker
          st   rv,buffer.end←mod(source)
          bal  link,set←mark←reg
ms.is←end lis  temp,0
          st   temp,marker.mv(rv)
          sth  temp,screen.displayed(screen)
          lcs  temp,1
          st   temp,screen.force←display(screen)

          l    line,op2(ops)                 get starting line
          sth  line,screen.line←on←screen(screen)
          l    temp,screen←chain
          st   temp,screen.next(screen)      thread it on the list
          st   screen,screen←chain

          sth  type,screen.last←line(screen)
          lis  line,0
          lh   get,screen.line←on←screen(screen)
          sis  get,1
          slls get,2
ms.loop   bal  link,make←marker
          st   rv,screen.start(line,screen)
          lis  index,0
          bal  link,set←mark←reg             uses source,rv,index
          clr  line,type
          bnls ms.skip
          st   screen,lines.screen(get,lp)
ms.skip   ais  line,4
          ais  get,4
          clr  line,type
          bnp  ms.loop

          lr   rv,screen

          b    popj

*    This just forces the redisplay of a window.

     instruction    force←display
          l    screen,op1(ops)
          l    temp,op2(ops)                 get line for center or -1
          st   temp,screen.force←display(screen)
          br   link

*    This routine which makes sure that all windows on the screen are
*    correct.

     instruction    display
          save


          l    rv,linel←ptr
          l    temp,variable.value(rv)
          sth  temp,linel

          lis  line,0                   start at first line
disp.next l    screen,lines.screen(line,lp)
          bzs  disp.inc←line
          bal  link,scan←for←damage
disp.inc←line  equ  *
          bal  link,show←line
          ais  line,4
          clhi line,num←of←lines*4
          bps  reset←screen
          cl   screen,lines.screen(line,lp)
          bes  disp.inc←line            another line on same screen
          b    disp.next                new and different screen

reset←screen   l    screen,screen←chain
disp.reset←l   lh   temp,screen.displayed(screen)
          bz   reset←next
reset←it  l    source,screen.buffer(screen)  reset the modification markers
          l    rv,buffer.start←mod(source)
          l    temp,buffer.top(source)
          st   temp,marker.mv(rv)
          l    rv,buffer.end←mod(source)
          lis  temp,0
          st   temp,marker.mv(rv)
          sth  temp,screen.displayed(screen)
          st   temp,screen.force←display(screen)
reset←next     l    screen,screen.next(screen)
          bnz  disp.reset←l

          l    t1,current←screen←ptr
          l    screen,variable.value(t1)
          l    source,screen.buffer(screen)
          l    index,buffer.location(source)
          cl   index,buffer.gap←start(source)
          bnps disp.index←bg
          a    index,buffer.gap←end(source)
          s    index,buffer.gap←start(source)

disp.index←bg  equ  *
          lis  line,0
          l    t1,screen.start(line,screen)  get marker for line start
          cl   index,marker.mv(t1)
          bl   popj
          lh   get,screen.last←line(screen)
disp.find←pt   ais  line,4
          clr  line,get
          bp   popj                          have fallen off bottom.
          l    t1,screen.start(line,screen)
          cl   index,marker.mv(t1)
          bnls disp.find←pt
          sis  line,4
          st   index,save.index
          lis  index,0
          bal  link,get←init
          lis  colno,1
          l    index,screen.start(line,screen)
          l    index,marker.mv(index)
disp.find←pos  cl   index,save.index
          bnls disp.position
          bal  link,assemble←char
          bs   disp.find←pos
disp.position  equ  *
          lhi  char,c'xy'                    position to right place
          sth  char,dispop
          sth  colno,x←cord
          lr   char,line
          srls char,2
          ah   char,screen.line←on←screen(screen)
          sth  char,y←cord

          la   char,user←output              setup for call to order
          st   char,arg1p(sp)
          la   char,curpos←string
          st   char,arg2p(sp)
          la   char,pos←struc←ptr
          st   char,arg3p(sp)
          la   char,code(sp)
          st   char,arg4p(sp)
          lhi  char,20
          st   char,alist←size(sp)
          la   ap,alist(sp)

          save
          bal  link,scs$order
          restore

          b    popj

scan←for←damage equ *

          lh   temp,screen.displayed(screen)      already done
          bnzr link
          lis  temp,1
          sth  temp,screen.displayed(screen)

          save

*         line points to first line in window.
*         screen is set to screen for this window.

*         First we have to see where the modifications are.

          lcs  temp,1
          sth  temp,screen.first←mod(screen) initialize this
          lh   temp,screen.line←on←screen(screen)
          sis  temp,1
          slls temp,2
          sr   line,temp                     get to screen relative line
          l    source,screen.buffer(screen)
          l    t1,screen.force←display(screen)    special display instructions
          bm   us.center
          bnz  us.blast←marks
          lh   get,screen.last←line(screen)  this is a random reg. ICB
          lr   type,line                     use type to find pt
          l    index,buffer.location(source)
          cl   index,buffer.gap←start(source)     make marker type ptr
          bnps us.index←bg
          a    index,buffer.gap←end(source)
          s    index,buffer.gap←start(source)

us.index←bg    equ  *
          l    t1,screen.start(type,screen)  get marker for line start
          cl   index,marker.mv(t1)
          bl   us.center
us.find←pt     ais  type,4
          clr  type,get
          bp   us.center                     have fallen off bottom.
          l    t1,screen.start(type,screen)
          cl   index,marker.mv(t1)
          bps  us.find←pt

*         By the time we get here "line" is first line and "get" is last line
*         and type is line after point.

          clh  type,screen.last←line(screen) off the bottom?
          be   us.center
          l    t1,buffer.start←mod(source)
          l    temp,marker.mv(t1)
          l    t1,buffer.end←mod(source)
          cl   temp,marker.mv(t1)            any modifications?
          bp   popj                          not a thing to do!
          l    rv,screen.start(line,screen)
          cl   temp,marker.mv(rv)
          bnl  us.just←scan                  if after first line then win
          l    t1,buffer.end←mod(source)
          l    temp,marker.mv(t1)
          cl   temp,marker.mv(rv)            is end above us too?
          bnp  popj                          no real work to do

*    weird←backup←hack is here.  This routine finds the starting position
*    of the top of the screen.  t1 points to the end←mod marker. line
*    point to first line and type points to line after pt. get points
*    to last line in window.

*    First thing to do is find out how many lines to back up.  We
*    start at end←mod unless off the screen.  If it is off then go
*    half a screen up from pt.

          l    rv,screen.start(get,screen)
          l    temp,marker.mv(t1)            compare end←mod to last line
          cl   temp,marker.mv(rv)
          bnl  wbh.count←em
us.center lh   t1,screen.last←line(screen)
          srls t1,3                          divide by two
us.blast←marks equ  *
          lis  temp,0
          lis  rv,0
us.bm.loop     equ  *
          l    index,screen.start(rv,screen)
          st   temp,marker.mv(index)
          ais  rv,4
          clh  rv,screen.last←line(screen)
          bnps us.bm.loop

          l    index,buffer.location(source) place to start from
          cl   index,buffer.gap←start(source)
          bnp  wbh.count←back
          a    index,buffer.gap←end(source)  make absolute
          s    index,buffer.gap←start(source)
          b    wbh.count←back

*         This finds the line before end←mod.  We will fill from here
*         back from the "points" on the stack.

wbh.count←em   sis  get,4               temp has marker.mv(t1) in it
          cr   get,line                      at the beginning yet?
          bnps wbh.set←start
          l    rv,screen.start(get,screen)
          cl   temp,marker.mv(rv)            find line before end←mod
          bnp  wbh.count←em
wbh.set←start  ais  get,4               we really want one more
          l    t1,screen.start(get,screen)   for eval←mark←reg
          l    index,marker.mv(t1)           place for back up to start
          sr   get,line
          srls get,2
          lr   t1,get                        save numer of lines here

*    t1 is number of lines to count back and index is the place to start.
*    we look for t1 CRs or t1*linel chars.

wbh.count←back save                          so we can bash line,screen
          st   index,save.index              place to stop when going for.
          lr   temp,t1                       number of lines from top
          slls temp,2
          ar   temp,line
          st   temp,save.count               save line number to start on
          lr   t2,index
          bal  link,getr←init                so we can get chars in rev.
          lr   index,t2

          ais  t1,1                          one extra line for good measure
          lr   t2,t1
          mh   t2,linel
wbh.back←loop  balr link,get
          b    wbh.forward                   if we fell off end
          sis  t2,1                          got a char
          bm   wbh.forward
          clhi char,x'0d'                    if a cr then dec. t1 too
          bnes wbh.back←loop
          sis  t1,1
          bnm  wbh.back←loop

*    Now index is a marker type value giving our position.
*    The idea is now to move forward pushing the position of each line onto
*    the stack as we go.  When we reach the marker position of the first line
*    after end←mod we take the top N lines of the stack and put them into
*    lines.start and pop the rest away.

wbh.forward    lr   rv,index                      so we can save it.
          ais  rv,1                          we backed up too far.
          restore
          st   stack,save.stack              so we can pop right.
          st   screen,save.screen            instead of a push
          st   line,save.line
          lr   t1,rv                         save index across get←init
          bal  link,get←init                 setup for call to get←line
          lr   index,t1                      was saved from above
          l    t1,save.index                 posn to stop at
          lis  type,0
wbh.for←loop   st   index,0(stack)                save the start of each line
          ais  stack,4
          bal  link,get←line
          lr   index,rv                      get←line does a restore...
          lr   char,char
          bm   wbh.unwind.c                  if char&lt;0 then ran off end
          clr  index,t1
          bls  wbh.for←loop                  need more lines still
          bes  wbh.unwind
          bs   wbh.unwind.f

wbh.unwind.c   ais  type,1                        clear rest of screen
wbh.unwind     equ  *    
wbh.unwind.f   ais  type,1                        keep on filling
          l    line,save.line                hit it right on.
          l    t1,save.count
wbh.pop←next   l    rv,screen.start(t1,screen)
          lis  temp,0
          cl   stack,save.stack
          bes  wbh.filling                   no pop, fill with zeros
          sis  stack,4
          l    temp,0(stack)
wbh.filling    cl   temp,marker.mv(rv)
          bes  wbh.line←same                 already set right
          st   temp,marker.mv(rv)
          lr   temp,t1                       means mungeds start ptrs
          srls temp,2
*(problem with one line windows?)
          sbt  temp,screen.force←display(screen)
          sis  temp,1                        previos line is changed
          sbt  temp,screen.force←display(screen)  mark it for update
wbh.line←same  sis  t1,4
          cr   t1,line                       done yet?
          bnm  wbh.pop←next
          l    stack,save.stack              pop off any extra

          lr   type,type
          be   popj                          we're done
          l    t1,save.count                 get line to continue at
          clhi type,1
          be   wbh.start←sl                  go on filling screen
          lh   temp,screen.last←line(screen)
          lr   rv,t1
          srls rv,2           make it a bit ptr
          sis  rv,1                          if different mark last line
wbh.fd←loop    ais  t1,4           get to next line
          ais  rv,1
          cr   t1,temp
          bp   popj
          l    get,screen.start(t1,screen)
          cl   index,marker.mv(get)
          be   popj
          st   index,marker.mv(get)
          sbt  rv,screen.force←display(screen)
          b    wbh.fd←loop

wbh.start←sl   equ  *
          ais  t1,4
          l    line,screen.start(t1,screen)
          cl   index,marker.mv(line)         are we in synch
          be   popj
          st   index,marker.mv(line)         fill in line we overflowed to.
          lr   line,t1                       setup for branching into js
          srls t1,2                          make into bit ptr
          sbt  t1,screen.force←display(screen)
          b    js.wbh←gate

*    In this place we scan from the line containing start←mod to the line
*    containing end←mod or the end of the screen.

*    Comming in here only line and screen are relied on.

*    First we want to set up for call to get←init and hence get←line.
*    This involves setting index to eval(marker.mv) of the line before
*    start←mod.  Then just setting up starting and stopping conditions.

us.just←scan   l    rv,buffer.start←mod(source)
          l    temp,marker.mv(rv)
          lh   t1,screen.last←line(screen)

js.find←start  l    rv,screen.start(line,screen)
          cl   temp,marker.mv(rv)
          bls  js.found←start
          ais  line,4
          clr  line,t1
          bnps js.find←start
          b    popj                          nothing to do

js.found←start equ  *
          sis  line,4         back up one.
          sth  line,screen.first←mod(screen) save this
          l    t1,screen.start(line,screen)
          bal  link,eval←mark←reg
          lr   index,rv
js.wbh←gate    lr   type,line                     save the starting line
          l    rv,buffer.end←mod(source)
          l    temp,marker.mv(rv)
          lh   t1,screen.last←line(screen)   set up last line

js.find←end    l    rv,screen.start(line,screen)
          cl   temp,marker.mv(rv)
          bnps js.found←end                  find line just passed end←mod
          clr  line,t1
          bnls js.found←end
          ais  line,4
          bs   js.find←end

js.found←end   lr   t1,line                  save this for the loop
          lr   line,type                     this is where we start.
*         ais  line,4                        compare with next line
          bal  link,get←init
          lr   type,t1                       this is end←mod
          lh   t1,screen.last←line(screen)   This is really the end.

js.scan←loop   bal  link,get←line
          lr   index,rv
          l    rv,screen.start(line,screen)
          clr  line,type                     are we past end←mod yet?
          bls  js.skip←test
          cl   index,marker.mv(rv)           are we in sync yet?
          be   popj                          line set so don't mark it
js.skip←test   st   index,marker.mv(rv)
          lr   temp,line
          srls temp,2
          sbt  temp,screen.force←display(screen)  mark this line
          ais  line,4
          clr  line,t1
          bnp  js.scan←loop
          b    popj

colno          equ  first←free+7                  So put←ptr and sink can be used

get←line       equ  *
*    This routine reads characters using "get" until it gets a full line.
*    It returns with reg 0 (char ,temp) set to -1 if it is at the end
*    of the buffer.
          save
          lis  colno,1
gl.loop        st   index,save.index              save incase we have to backup
          bal  link,assemble←char
          lr   char,char
          bms  gl.return
          clhi char,x'0d'                    CR
          bes  gl.return
gl.check←colno clh  colno,linel
          bes  gl.return
          bl   gl.loop                       still more room.
          l    index,save.index              fell off end (back up one)
          bs   gl.return
gl.return      lr   rv,index                      so we can return index
          b    popj

*    This gets a char and increments colno by the approptiate amount

assemble←char  lr   rv,link
          balr link,get
          lr   link,rv
          br   link                          if error (fell off end)
          lr   link,rv                       returns here if get a char
          clhi char,x'0d'                    CR: resets colno
          bnes ac.not←cr
          st   colno,save.colno              save this for get←line
          lis  colno,1
          br   link
ac.not←cr      clhi char,x'09'                    Tab
          bnes ac.reg
          lr   type,colno                    uses type,sink which are cont.
          lis  0,5
          dhr  type,0                        remander->type,quotient->sink
          mhr  sink,0
          ais  sink,6
          lr   colno,sink
          br   link
ac.reg         lr   rv,char
          slls rv,1
          ah   colno,size←table(rv)
          br   link

*    This routine check the current line and checks
*    the damage switch.  If the switch is set the line is assembled
*    and output at the appropriate place on the screen.  If only the
*    redisplay switch is set then that line is output from the
*    start←mod position to the end of the line.

show←line      equ *
          lr   screen,screen
          bzr  link                          we get some real weirdos!
          save

          l    source,screen.buffer(screen)
          lh   temp,screen.line←on←screen(screen)
          sis  temp,1
          lr   rv,temp                       bit ptr to line flags
          slls temp,2
          sr   line,temp                     get line relative to screen

          clh  line,screen.first←mod(screen)
          bes  sl.start←mod                  do this line.

          lr   rv,line
          srls rv,2
          tbt  rv,screen.force←display(screen)
          bz   popj
          b    sl.stuff←it

*    This means output line from start←mod to end else same as negative flag

sl.start←mod   equ  *
          lis  index,0
          bal  link,get←init

          l    rv,screen.start(line,screen)
          l    index,marker.mv(rv)
          lis  colno,1
          l    rv,buffer.start←mod(source)        go to sm before printing
          l    type,marker.mv(rv)
sl.find←sm     clr  index,type                         stop at start←mod
          bnl  sl.put←it
          bal  link,assemble←char                 this bashes rv
          clhi char,x'0d'
          bnes sl.find←sm
          lis  temp,4
          ahm  temp,screen.first←mod(screen)      sm is really on next line
          b    popj                               punt if sm is at end of line

sl.stuff←it    equ  *
          lis  index,0
          bal  link,get←init
          l    rv,screen.start(line,screen)
          l    index,marker.mv(rv)
          lis  colno,1
sl.put←it la   type,io←buffer(sp)                 running low on regs
          l    rv,screen.start+4(line,screen)
sl.stuff←l     equ  *
          cl   index,marker.mv(rv)                are we done yet?
          bnls sl.output
          balr link,get
          b    error11                            can't report this as an error
*         bal  link,error                         shouldn't run out of chars
error11   equ  *
          clhi char,x'0d'
          bes  sl.output
          stb  char,0(type)
          ais  type,1
          bs   sl.stuff←l

sl.output lhi  char,c'xy'                    position to right place
          sth  char,dispop
          sth  colno,x←cord
          lr   char,line
          srls char,2
          ah   char,screen.line←on←screen(screen)
          sth  char,y←cord

          la   char,user←output              setup for call to order
          st   char,arg1p(sp)
          la   char,curpos←string
          st   char,arg2p(sp)
          la   char,pos←struc←ptr
          st   char,arg3p(sp)
          la   char,code(sp)
          st   char,arg4p(sp)
          lhi  char,20
          st   char,alist←size(sp)
          la   ap,alist(sp)

          save
          bal  link,scs$order
*
          lhi  char,c'cl'                    clear the line too
          sth  char,dispop
          bal  link,scs$order
*
          lr   char,type                     calculate line size
          shi  char,io←buffer(sp)
          st   char,io←buffer←len(sp)
          la   char,io←buffer←ptr(sp)        set up for call to put←chars
          st   char,arg2p(sp)
          la   char,io←buffer←len(sp)
          st   char,arg3p(sp)
          bal  link,iocs$put←chars
          restore

          b    popj


size←table     equ  *
          dc   2,2,2,2,2,2,0,-1,0,0,2,2,0,2,2,2
          dc   2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2
          dc   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
          dc   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
          dc   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
          dc   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
          dc   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
          dc   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
          dc   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
          dc   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0

linel←string   dc   5,c'linel'
current←screen←string    dc   14,c'current←screen'


screen←chain   dac  0

pos←struc←ptr  dac  0
curpos←string  dc   c'cur←pos '
pos←struc      equ  *
dispop         dc   c'xy'
x←cord         dc   0
y←cord         dc   0

num←of←lines   equ  25
          align 4
lines.screen   ds   num←of←lines*4
lines.next     ds   num←of←lines*4

linel          dc   80

          align 4
linel←ptr      ds   4
current←screen←ptr  ds   4

save.count     dac  0
save.stack     dac  0
save.screen    dac  0
save.line      dac  0
save.index     dac  0
save.colno     dac  0

↑L 
     Listing of >s>langs>sine>stack.incl.pl1 12/30/79 17:28:03

/*
Frame: The stuff in every stack frame.
Arguments: These immediately preceed every stack frame.
Bindings: These allow the values of global variables to be restored.
Handlers: This is the list of "conditions" and places to go to handle them.
*/

declare
     1 frame based (sb),
          2 saved←pc,
               3 buf ptr,
               3 loc fixed(31),
          2 saved←sb pointer,
          2 saved←sp pointer,
          2 saved←ip pointer,
          2 name←of←function pointer,
          2 handlers ptr,
          2 flag←bits fixed,
          2 num←args fixed,
          2 num←temps fixed,
          2 num←bound fixed,
          2 temps (0:1) pointer;

declare
     arguments (0:1) pointer based (sb); /* Used with negative indexes */

declare
     1 bindings based,
          2 object pointer,
          2 value←addr ptr,
          2 old←value pointer;

declare
     1 handlers based,
          2 next pointer,
          2 addr←buf pointer,
          2 addr←loc fixed(31),
          2 contour ptr,
          2 name char(8);

↑L 
     Listing of >s>langs>sine>ops.incl.pl1   12/30/79 17:28:03

/*
     This is a table in which the number of operands that each opcode
     uses is looked up.
*/

  declare
     ops (10) fixed binary(7) static init(
2,   /* add */
2,   /* move */
0,   /* rtn */
9,
9,
9,
9,
9,
9,
9
                                        );
↑L 
     Listing of >s>langs>sine>data←types.incl.pl1 12/30/79 17:27:56

/*
Buffer: An extensible and modifiable text string.
*/

declare
     1 buffer based,          /* type = 1 */
          2 next pointer,
          2 base pointer,
          2 real←hole ptr,    /* AS←ptr | seg←ptr */
          2 location fixed(31),
          2 gap←start fixed(31),
          2 gap←end fixed(31),
          2 top fixed(31),
          2 start←mod ptr,
          2 end←mod ptr,
          2 marker←chain ptr,
          2 flags bit(24),
          2 file←suffix char(1);
/*
String: An extensible text string.
*/

declare
     1 string based,          /* type = 2 */
          2 length fixed,
          2 text char(1);

/*
Window: A virtual buffer or string
*/

declare
     1 window based,          /* type = 3 */
          2 start ptr,
          2 stop ptr,
          2 real←text pointer;

/*
Cons: A two object data container.
*/

declare
     1 cons based,            /* type = 4 */
          2 car pointer,
          2 cdr pointer;

/*
Variable: A data container with a name.
*/

declare
     1 variable based,        /* type = 5 */
          2 next pointer,
          2 name pointer,
          2 value pointer;

/*
Function: A cons with the car a pc and the cdr a ptr tp the linkage section.
*/

declare
     1 function based,        /* type = 6 */
          2 buf ptr,
          2 loc fixed(31),
          2 vbl←tab pointer;

/*
Marker: A pointer into a buffer which is attached to the text.
*/

declare
     1 marker based,          /* type = 7 */
          2 next ptr,
          2 marker←value fixed(31);

/*
Screen: This is the data kept around for each displayable window.
*/

declare
     1 screen based,          /* type = 8 */
          2 next ptr,
          2 buffer ptr,
          2 lise←on←screen fixed,
          2 last←line fixed,
          2 just char(20),
          2 start(25) ptr;

/*
Array: This is a standard array type header.
*/

declare
     1 array based,           /* type = 9 */
          2 type fixed(31),
          2 size fixed(31),        /* number of cells if &lt;type> bits each */
          2 cells (1) ptr;         /* the cells themselves */
/*
Gnirt: This is an extensible.  It can be inserted into and deleted from
but the current location is always at the end.
*/

declare
     1 gnirt based,           /* type = 10 */
          2 max←length fixed,      /* size of this block: can grow to this
                                      size before reallocation is necessary */
          2 real←length fixed,
          2 real←text ptr;         /* where the text really is */

/*
Vbl←tab: this is a hack for the garbage collector.
*/

declare
     1 vbl←tab based,         /* type = 11 */
          2 num←static fixed,
          2 num fixed,
          2 vbls (1) ptr;

↑L 
     Listing of >s>langs>sine>state.incl.pl1 12/30/79 17:27:54

 dcl 1 state,
          2 pc,
               3 buf ptr,
               3 loc fixed(31),
          2 sb ptr,
          2 sp ptr,
          2 ip ptr,
     fsb fixed(31) defined sb,
     fsp fixed(31) defined sp;
↑L 
     Listing of >s>langs>sine>opcodes.incl.pl1    12/30/79 17:27:47

dcl numops fixed init (124);
dcl opcodes (124) fixed static init (
140,
135,
134,
121,
116,
114,
120,
104,
96,
129,
128,
127,
126,
125,
124,
123,
122,
95,
94,
93,
92,
91,
90,
89,
88,
86,
84,
83,
82,
108,
80,
79,
132,
78,
77,
130,
76,
74,
106,
71,
70,
57,
56,
55,
51,
50,
49,
48,
47,
131,
46,
105,
101,
45,
85,
75,
44,
43,
113,
133,
42,
41,
40,
107,
37,
36,
136,
35,
87,
103,
34,
33,
32,
31,
30,
29,
28,
119,
118,
117,
115,
102,
27,
26,
25,
24,
98,
97,
73,
72,
23,
22,
100,
99,
21,
137,
81,
20,
19,
18,
38,
17,
16,
15,
14,
13,
12,
11,
112,
111,
110,
109,
10,
9,
8,
7,
6,
61,
60,
5,
4,
3,
2,
1);
dcl opname (124) char(16) static init (

"0",
"get←documentation",
"make←read←only",
"get←hpos",
"get←pname",
"restart←at",
"call←af",
"cline",
"command←args",
"find←first←not←in←br",
"find←first←not←in←ba",
"find←first←not←in←fr",
"find←first←not←in←fa",
"find←first←in←br",
"find←first←in←ba",
"find←first←in←fr",
"find←first←in←fa",
"over←token←br",
"over←token←ba",
"over←token←fr",
"over←token←fa",
"to←token←br",
"to←token←ba",
"to←token←fr",
"to←token←fa",
"define←window",
"bind←array←cell",
"quote",
"eval",
"load",
"write←file",
"read←file",
"copy←array",
"as",
"ar",
"fill←char←array",
"fill←vbl←array",
"discard",
"signal",
"revert",
"handle",
"eval←mark",
"unset←mark",
"set←mark",
"delete",
"add←to←loc",
"set←loc",
"length",
"location",
"nthr",
"nth",
"insert←ioa",
"insert←region",
"insert",
"make←gnirt",
"make←array",
"make←screen",
"make←mark",
"intern",
"make←variable",
"make←window",
"make←string",
"make←buffer",
"display←screen",
"force←display",
"display",
"estore",
"store",
"tyis",
"print←clearing",
"print",
"tyo",
"tyi",
"rsearchr",
"searchr",
"rsearch",
"search",
"variablep",
"stringp",
"functionp",
"looking←atp",
"modifiedp",
"lep",
"lp",
"gep",
"gp",
"not",
"eq",
"bnoerr",
"berr",
"ifnil",
"ift",
"nil",
"t",
"goto",
"bind←static",
"bind←vbl",
"bind",
"num←args",
"return",
"call←vbl",
"call",
"squish",
"pop",
"push",
"rplacd",
"rplaca",
"cons",
"cddr",
"cdar",
"cadr",
"caar",
"cdr",
"car",
"xor",
"or",
"and",
"max",
"min",
"mod",
"div",
"mul",
"sub",
"add");
↑L 
     Listing of >s>langs>sine>data←types.incl.sysin    12/30/79 17:27:59

 pc 0
 org 0
*    buffer
buffer←bits equ x'10000000'
buffer←type equ 1
buffer.next ds 4
base equ *
buffer.base ds 4
buffer.real←hole ds 4
buffer.location ds 4
gap←start equ *
buffer.gap←start ds 4
gap←end equ *
buffer.gap←end ds 4
top equ *
buffer.top ds 4
buffer.start←mod ds 4
buffer.end←mod ds 4
marker←chain equ *
buffer.marker←chain ds 4

buffer.flags ds 4
buffer.flags.read←only equ 0
buffer.flags.wired equ 1

buffer←size equ *
*
 org 0
*    string
string←bits equ x'20000000'
string←type equ 2
string.length ds 2
string.text ds 1
string←size equ *
*
 org 0
*    window
window←bits equ x'30000000'
window←type equ 3
window.start ds 4
window.stop ds 4
window.real←text ds 4
window←size equ *
*
 org 0
*    cons
cons←type equ 4
cons←bits equ x'40000000'
cons.car ds 4
cons.cdr ds 4
cons←size equ *
*
 org 0
*    variable
variable←type equ 5
variable←bits equ x'50000000'
variable.next ds 4
variable.name ds 4
variable.value ds 4
variable←size equ *
*
 org 0
*    function
function←type equ 6
function←bits equ x'60000000'
function.buf ds 4
function.loc ds 4
function.vbl←tab ds 4
function←size equ *
*
 org 0
*    marker
marker←bits equ x'70000000'
marker←type equ 7
marker.next ds 4
marker.mv ds 4
marker←size equ *
*
 org 0
*    screen
screen←type equ 8
screen←bits equ x'80000000'
screen.next ds 4
screen.buffer ds 4
screen.line←on←screen ds 2
screen.last←line ds 2
screen.first←mod ds 2
screen.displayed ds 2
screen.current←line ds 2
screen.pad ds 2
screen.force←display ds 4
screen.emptyp ds 4
screen.last←top ds 4
screen←size equ *
screen.start ds 4 n lines start here.
screen.linel ds 2
screen.scrap ds 2
line←array←size equ 8
line←array←shift equ 3

array←bits     equ  x'90000000'
array←type     equ  9
               org  0
array          equ  *
array.type     ds   4
array.size     ds   4
array.cells    equ  *
array←size     equ  *

 org 0
gnirt←bits          equ  x'a0000000'
gnirt←type          equ  10
gnirt.max←length    ds   2
gnirt.real←length   ds   2
gnirt.text←ptr      ds   4
gnirt←size          equ  *

 org 0
vbl←tab←bits        equ  x'b0000000'
vbl←tab←type        equ  11
vbl←tab.num         ds   4
vbl←tab.vbls        equ  *

 org 0
frame equ *
frame.saved←pc.buf ds 4
frame.saved←pc.loc ds 4
frame.saved←sb ds 4
frame.saved←sp ds 4
frame.saved←ip ds 4
frame.name←of←function ds 4
frame.handlers ds 4
frame.flag←bits ds 2
frame.num←args ds 2
frame.num←temps ds 2
frame.num←bound ds 2
frame.temps equ *
frame←size equ *

     org  0
bindings equ *
bindings.variable ds 4
bindings.value←addr ds 4
bindings.old←value ds 4

 org 0
handler.next ds 4
handler.addr.buf ds 4
handler.addr.loc ds 4
handler.contour ds 4
handler.error←name ds 8
handler←size equ *

 pure
↑L 
     Listing of >s>langs>sine>macros.incl.sysin   12/30/79 17:28:04

*
*    OTA's macro package
*         (I just can't resist hacking macros any longer)
*

save macro
 stm 2,0(stack)
 ahi stack,56
 mend

restore macro
 lm 2,-56(stack,0)
 mend

↑L 
     Listing of >s>langs>sine>opcodes.incl.sysin  12/30/79 17:27:22

 org 12+op←tab←origin
 dc 1,1,0,0,1,add
 org 24+op←tab←origin
 dc 1,1,0,0,1,sub
 org 36+op←tab←origin
 dc 1,1,0,0,1,mul
 org 48+op←tab←origin
 dc 1,1,0,0,1,div
 org 60+op←tab←origin
 dc 1,1,0,0,1,mod
 org 720+op←tab←origin
 dc 1,1,0,0,1,min
 org 732+op←tab←origin
 dc 1,1,0,0,1,max
 org 72+op←tab←origin
 dc x'0801',x'0801',0,0,1,and
 org 84+op←tab←origin
 dc x'0801',x'0801',0,0,1,or
 org 96+op←tab←origin
 dc x'0801',x'0801',0,0,1,xor
 org 108+op←tab←origin
 dc x'0010',0,0,0,1,car
 org 120+op←tab←origin
 dc x'0010',0,0,0,1,cdr
 org 1308+op←tab←origin
 dc x'0010',0,0,0,1,caar
 org 1320+op←tab←origin
 dc x'0010',0,0,0,1,cadr
 org 1332+op←tab←origin
 dc x'0010',0,0,0,1,cdar
 org 1344+op←tab←origin
 dc x'0010',0,0,0,1,cddr
 org 132+op←tab←origin
 dc x'3fff',x'3fff',0,0,1,cons
 org 144+op←tab←origin
 dc x'0010',x'3fff',0,0,1,rplaca
 org 156+op←tab←origin
 dc x'0010',x'3fff',0,0,1,rplacd
 org 168+op←tab←origin
 dc x'3fff',0,0,0,1,push
 org 180+op←tab←origin
 dc x'4000',0,0,0,0,pop
 org 192+op←tab←origin
 dc 1,0,0,0,0,squish
 org 204+op←tab←origin
 dc x'8000',1,0,0,0,call
 org 456+op←tab←origin
 dc x'0020',1,0,0,0,call←vbl
 org 216+op←tab←origin
 dc 0,0,0,0,1,return
 org 228+op←tab←origin
 dc 1,0,0,0,1,num←args
 org 240+op←tab←origin
 dc x'8000',0,0,0,0,bind
 org 972+op←tab←origin
 dc x'0020',0,0,0,0,bind←vbl
 org 1644+op←tab←origin
 dc x'4000',0,0,0,0,bind←static
 org 252+op←tab←origin
 dc 1,0,0,0,0,goto
 org 1188+op←tab←origin
 dc 0,0,0,0,1,t
 org 1200+op←tab←origin
 dc 0,0,0,0,1,nil
 org 264+op←tab←origin
 dc x'3fff',1,0,0,1,ift
 org 276+op←tab←origin
 dc x'3fff',1,0,0,1,ifnil
 org 864+op←tab←origin
 dc 1,0,0,0,0,berr
 org 876+op←tab←origin
 dc 1,0,0,0,0,bnoerr
 org 1164+op←tab←origin
 dc x'3fff',x'3fff',0,0,1,eq
 org 1176+op←tab←origin
 dc x'3fff',0,0,0,1,not
 org 288+op←tab←origin
 dc x'3fff',x'3fff',0,0,1,gp
 org 300+op←tab←origin
 dc x'3fff',x'3fff',0,0,1,gep
 org 312+op←tab←origin
 dc x'3fff',x'3fff',0,0,1,lp
 org 324+op←tab←origin
 dc x'3fff',x'3fff',0,0,1,lep
 org 1224+op←tab←origin
 dc 2,0,0,0,1,modifiedp
 org 1380+op←tab←origin
 dc x'040f',2,1,0,1,looking←atp
 org 1404+op←tab←origin
 dc x'3fff',0,0,0,1,functionp
 org 1416+op←tab←origin
 dc x'3fff',0,0,0,1,stringp
 org 1428+op←tab←origin
 dc x'3fff',0,0,0,1,variablep
 org 336+op←tab←origin
 dc 2,x'040f',0,0,1,search
 org 348+op←tab←origin
 dc 2,x'040f',0,0,1,rsearch
 org 360+op←tab←origin
 dc 2,x'040f',0,0,1,searchr
 org 372+op←tab←origin
 dc 2,x'040f',0,0,1,rsearchr
 org 384+op←tab←origin
 dc 0,0,0,0,1,tyi
 org 396+op←tab←origin
 dc 1,0,0,0,1,tyo
 org 408+op←tab←origin
 dc x'040f',1,1,1,1,print
 org 1236+op←tab←origin
 dc x'040f',1,1,1,1,print←clearing
 org 1044+op←tab←origin
 dc 0,0,0,0,1,tyis
 org 420+op←tab←origin
 dc x'3fff',x'4000',0,0,1,store
 org 1632+op←tab←origin
 dc x'3fff',x'0020',0,0,1,estore
 org 432+op←tab←origin
 dc 0,0,0,0,0,display
 org 444+op←tab←origin
 dc x'0100',1,0,0,1,force←display
 org 1284+op←tab←origin
 dc x'0101',1,1,0,0,display←screen
 org 480+op←tab←origin
 dc 0,0,0,0,1,make←buffer
 org 492+op←tab←origin
 dc x'040f',0,0,0,1,make←string
 org 504+op←tab←origin
 dc x'0002',0,0,0,1,make←window
 org 1596+op←tab←origin
 dc x'040f',0,0,0,1,make←variable
 org 1356+op←tab←origin
 dc x'040f',x'0200',0,0,1,intern
 org 516+op←tab←origin
 dc 0,0,0,0,1,make←mark
 org 528+op←tab←origin
 dc 2,0,0,0,1,make←screen
 org 900+op←tab←origin
 dc 1,1,0,0,1,make←array
 org 1020+op←tab←origin
 dc 0,0,0,0,1,make←gnirt
 org 540+op←tab←origin
 dc x'040f',x'0402',0,0,1,insert
 org 1212+op←tab←origin
 dc x'040b',1,1,x'0402',1,insert←region
 org 1260+op←tab←origin
 dc x'040e',x'3fff',x'0402',0,1,insert←ioa
 org 552+op←tab←origin
 dc x'040e',1,0,0,1,nth
 org 1572+op←tab←origin
 dc 2,1,0,0,1,nthr
 org 564+op←tab←origin
 dc 2,0,0,0,1,location
 org 576+op←tab←origin
 dc x'040f',0,0,0,1,length
 org 588+op←tab←origin
 dc 2,1,0,0,1,set←loc
 org 600+op←tab←origin
 dc 2,1,0,0,1,add←to←loc
 org 612+op←tab←origin
 dc x'0402',1,0,0,1,delete
 org 660+op←tab←origin
 dc x'0080',2,1,0,1,set←mark
 org 672+op←tab←origin
 dc x'0080',2,0,0,1,unset←mark
 org 684+op←tab←origin
 dc x'0080',2,0,0,1,eval←mark
 org 840+op←tab←origin
 dc x'040e',1,0,0,0,handle
 org 852+op←tab←origin
 dc 0,0,0,0,0,revert
 org 1272+op←tab←origin
 dc x'040f',0,0,0,0,signal
 org 888+op←tab←origin
 dc 0,0,0,0,0,discard
 org 912+op←tab←origin
 dc x'0200',1,0,0,0,fill←vbl←array
 org 1560+op←tab←origin
 dc x'0200',x'040f',0,0,1,fill←char←array
 org 924+op←tab←origin
 dc x'0200',1,0,0,1,ar
 org 936+op←tab←origin
 dc x'3fff',x'0200',1,0,1,as
 org 1584+op←tab←origin
 dc x'0200',x'0201',0,0,1,copy←array
 org 948+op←tab←origin
 dc 2,x'040f',0,0,1,read←file
 org 960+op←tab←origin
 dc x'040f',x'040f',0,0,1,write←file
 org 1296+op←tab←origin
 dc x'040f',0,0,0,1,load
 org 984+op←tab←origin
 dc x'0020',0,0,0,1,eval
 org 996+op←tab←origin
 dc x'8000',0,0,0,1,quote
 org 1008+op←tab←origin
 dc x'0200',1,x'3fff',0,0,bind←array←cell
 org 1032+op←tab←origin
 dc x'0008',1,1,0,1,define←window
 org 1056+op←tab←origin
 dc 2,0,0,0,1,to←token←fa
 org 1068+op←tab←origin
 dc 2,0,0,0,1,to←token←fr
 org 1080+op←tab←origin
 dc 2,0,0,0,1,to←token←ba
 org 1092+op←tab←origin
 dc 2,0,0,0,1,to←token←br
 org 1104+op←tab←origin
 dc 2,0,0,0,1,over←token←fa
 org 1116+op←tab←origin
 dc 2,0,0,0,1,over←token←fr
 org 1128+op←tab←origin
 dc 2,0,0,0,1,over←token←ba
 org 1140+op←tab←origin
 dc 2,0,0,0,1,over←token←br
 org 1464+op←tab←origin
 dc 2,x'060f',0,0,1,find←first←in←fa
 org 1476+op←tab←origin
 dc 2,x'060f',0,0,1,find←first←in←fr
 org 1488+op←tab←origin
 dc 2,x'060f',0,0,1,find←first←in←ba
 org 1500+op←tab←origin
 dc 2,x'060f',0,0,1,find←first←in←br
 org 1512+op←tab←origin
 dc 2,x'060f',0,0,1,find←first←not←in←fa
 org 1524+op←tab←origin
 dc 2,x'060f',0,0,1,find←first←not←in←fr
 org 1536+op←tab←origin
 dc 2,x'060f',0,0,1,find←first←not←in←ba
 org 1548+op←tab←origin
 dc 2,x'060f',0,0,1,find←first←not←in←br
 org 1152+op←tab←origin
 dc 1,0,0,0,1,command←args
 org 1248+op←tab←origin
 dc x'040e',0,0,0,0,cline
 org 1440+op←tab←origin
 dc x'040f',0,0,0,1,call←af
 org 1368+op←tab←origin
 dc 1,0,0,0,0,restart←at
 org 1392+op←tab←origin
 dc x'0020',0,0,0,1,get←pname
 org 1452+op←tab←origin
 dc x'040f',1,0,0,1,get←hpos
 org 1608+op←tab←origin
 dc 2,0,0,0,1,make←read←only
 org 1620+op←tab←origin
 dc x'0020',0,0,0,1,get←documentation
 org 1680+op←tab←origin
 dc 0,0,0,0,0,0
↑L 
     Listing of >s>langs>sine>inst.incl.sysin     12/30/79 17:27:19


          extrn     $real←make←screen,$real←display,$real←force←display
          extrn     $real←print,scs$cl,scs$ioars←nnl,$real←display←screen
          extrn     $real←get←hpos
          entry     make←variable,make←mark,set←mark←reg,eval←mark←reg
          entry     tyi

*         This is the code for all the instructions sine knows about

     instruction    add
          l    rv,op1(ops)
          a    rv,op2(ops)
          br   link

     instruction    sub
          l    rv,op1(ops)
          s    rv,op2(ops)
          br   link

     instruction    mul
          l    9,op1(ops)
          m    8,op2(ops)
          lr   rv,9
          br   link

     instruction    div
          lis  8,0
          l    9,op1(ops)
          bnms div.ok
          lcs  8,1
div.ok    d    8,op2(ops)
          lr   rv,9
          br   link

     instruction    mod
          lis  8,0
          l    9,op1(ops)
          bnms mod.ok
          lcs  8,1
mod.ok    d    8,op2(ops)
          lr   rv,8
          br   link

     instruction    and
          l    rv,op1(ops)
          n    rv,op2(ops)
          br   link

     instruction    or
          l    rv,op1(ops)
          o    rv,op2(ops)
          br   link

     instruction    xor
          l    rv,op1(ops)
          x    rv,op2(ops)
          br   link

     instruction    min
          l    rv,op1(ops)
          c    rv,op2(ops)
          bnpr link
          l    rv,op2(ops)
          br   link

     instruction    max
          l    rv,op1(ops)
          c    rv,op2(ops)
          bnmr link
          l    rv,op2(ops)
          br   link

     instruction    car
          l    rv,op1(ops)
          l    rv,cons.car(rv)
          br   link

     instruction    cdr
          l    rv,op1(ops)
          l    rv,cons.cdr(rv)
          br   link

     instruction    caar
          l    rv,op1(ops)
          l    rv,cons.car(rv)
          l    rv,cons.car(rv)
          br   link

     instruction    cadr
          l    rv,op1(ops)
          l    rv,cons.cdr(rv)
          l    rv,cons.car(rv)
          br   link

     instruction    cdar
          l    rv,op1(ops)
          l    rv,cons.car(rv)
          l    rv,cons.cdr(rv)
          br   link

     instruction    cddr
          l    rv,op1(ops)
          l    rv,cons.cdr(rv)
          l    rv,cons.cdr(rv)
          br   link

     instruction    cons
          lis  5,8                           a cons is 8 bytes long
          save
          bal  link,allocate
          restore
          l    t2,op1(ops)
          st   t2,cons.car(rv)
          l    t2,op2(ops)
          st   t2,cons.cdr(rv)
          oi   rv,cons←bits
          br   link

     instruction    rplaca
          l    rv,op1(ops)
          l    t2,op2(ops)
          st   t2,cons.car(rv)
          br   link

     instruction    rplacd
          l    rv,op1(ops)
          l    t2,op2(ops)
          st   t2,cons.cdr(rv)
          br   link

init←routine   equ  t2

     instruction    rsearch
          la   init←routine,getr←init
          lr   t3,link                       we can bash about anything here
          bal  link,s.common
          ais  rv,1
          br   t3

     instruction    search
          la   init←routine,get←init
s.common  save
          lis  temp,0
          st   temp,error←register
          l    source,op2(ops)               string to search for
          la   temp,getr←init
          clr  temp,init←routine
          bnes s.not←rev
          bal  link,get←length               start at the end if in reverse
          lr   index,rv                      start at beginning
          sis  index,1
          bs   s.init
s.not←rev lis  index,0
s.init    st   index,segptr(sp)

          l    source,op1(ops)               get string to search though
          l    index,buffer.location(source)
          balr link,init←routine
s.restart save←sv   haystack
          l    source,op2(ops)
          l    index,segptr(sp)
          balr link,init←routine
          balr link,get
          b    s.found                       empty SS
          lr   type,char                     first find first char of SS
          save←sv   needle
          load←sv   haystack
s.look    balr link,get
          b    s.failed
error12   equ  *                             search failed
          clr  type,char
          bnes s.look

          lr   t1,index                      save for failing search
s.compare save←sv   haystack
          load←sv   needle
          balr link,get                      get next char in needle to check
          b    s.found
          lr   rv,char
          save←sv   needle
          load←sv   haystack
          balr link,get
          b    s.failed
          clr  rv,char
          be   s.compare
          lr   index,t1                      keep looking
          b    s.restart

s.found   equ  *
          l    rv,search←save←area←haystack+8     index(haystack)
          l    source,search←save←area←haystack   source(haystack)
          make←virtual←bufptr rv,source
          b    get←no←error

s.failed  lis  rv,0
          b    get←error

s.recover clhi t1,get←init                        doing search or rsearch?
          be   s.return←end
          lis  rv,0
          b    popj

s.return←end   equ  *
          l    source,op1(ops)
          bal  link,get←length
          b    popj

     instruction    searchr
          lr   t1,link
          bal  link,search
sr.common l    source,op1(ops)
          s    rv,buffer.location(source)
          br   t1

     instruction    rsearchr
          lr   t1,link
          bal  link,rsearch
          bs   sr.common

*         call iocs$get←chars (user←input,addr(buffer),num←chars,num←read,code);

     instruction    tyi
          stm  temp,register←save(sp)   incase of break!!!!
          lhi  temp,-2                  amount to backup if break hit
          sth  temp,break←enabled

          la   temp,user←input
          st   temp,arg1p(sp)
          la   temp,segptr(sp)          don't use io←buffer since we are called
          st   temp,segsize(sp)         by print which has stuff there
          la   temp,segsize(sp)
          st   temp,arg2p(sp)
          la   temp,a←one
          st   temp,arg3p(sp)
          la   temp,code
          st   temp,arg4p(sp)
          la   temp,code
          st   temp,arg5p(sp)
          lhi  temp,24
          st   temp,alist←size(sp)
          la   ap,alist(sp)
          save
          bal  link,iocs$get←chars
          lis  temp,0
          sth  temp,break←enabled
          restore

          lb   rv,segptr(sp)       get the char
          br   link

*         call iocs$put←chars (user←output, addr(io←buffer), num←chars, code);

     instruction    tyo
          l    t1,op1(ops)              get char to print
          stb  t1,io←buffer(sp)

          la   temp,user←output
          st   temp,arg1p(sp)
          la   temp,io←buffer←ptr(sp)
          st   temp,arg2p(sp)
          la   temp,a←one
          st   temp,arg3p(sp)
          la   temp,code
          st   temp,arg4p(sp)
          lhi  temp,20
          st   temp,alist←size(sp)
          la   ap,alist(sp)
          save
          bal  link,iocs$put←chars
          restore
          lr   rv,t1
          br   link

a←one     dac  1

*         Prints a text object

     instruction    print
          lis  rv,0                no clear to end of line
          b    $real←print

     instruction    print←clearing
          lis  rv,1
          b    $real←print

*         returns the number of characters in the input buffer

     instruction    tyis
          la   temp,user←input
          st   temp,arg1p(sp)
          la   temp,status←string
          st   temp,arg2p(sp)
          la   temp,io←buffer(sp)
          st   temp,io←buffer←ptr(sp)
          la   temp,io←buffer←ptr(sp)   returns input and output status in
          st   temp,arg3p(sp)           successive HWs.
          la   temp,code
          st   temp,arg4p(sp)
          lhi  temp,20
          st   temp,alist←size(sp)
          la   ap,alist(sp)
          save
          bal  link,iocs$order
          restore
          lh   rv,io←buffer(sp)
          br   link

status←string  equ  *
          dc   c'status  '

*         descriptor hacking

     instruction    cline
          save
          l    source,op1(ops)
          bal  link,get←length
          sth  rv,dscrs+2               build up pl/1 type descriptors
          lhi  rv,x'1400'
          sth  rv,dscrs
          lis  index,0
          bal  link,get←init
          la   t1,io←buffer(sp)
cline.loop     equ  *
          balr link,get
          b    cline.sendit
          stb  char,0(t1)
          ais  t1,1
          bs   cline.loop

cline.sendit   equ  *
          la   temp,io←buffer(sp)
          st   temp,arg1p(sp)
          lcs  temp,8                   negative => descriptors
          st   temp,alist←size(sp)
          la   10,dscrs
          la   15,alist(sp)
          bal  link,scs$cl
          b    popj

     instruction    call←af
          save
          lis  temp,0
          st   temp,error←register
          la   t1,3*56(stack)
          st   t1,arg1p(sp)
          li   temp,c'sine'
          st   temp,0(t1)
          li   temp,c'←mac'
          st   temp,4(t1)
          li   temp,c'hine'
          st   temp,8(t1)
          li   temp,c'$haf'
          st   temp,12(t1)
          lhi  temp,c' ['
          sth  temp,16(t1)
          l    source,op1(ops)
          la   t1,18(t1)
          lis  index,0
          bal  link,get←init
caf.get←loop   equ  *
          balr link,get
          bs   caf.do←call                   remember skip return
          dc   0
          stb  char,0(t1)
          ais  t1,1
          bs   caf.get←loop

caf.do←call    equ  *
          lhi  temp,c']'
          stb  temp,0(t1)
          shi  t1,3*56-1(stack)              get number of chars.
          sth  t1,dscrs+6
          lhi  temp,x'1400'
          sth  temp,dscrs+4

          la   temp,code(ls)
          st   temp,arg2p(sp)
          li   temp,x'1100001f'         fixed bin(31)
          st   temp,dscrs
          lcs  temp,12
          st   temp,alist←size(sp)

          save
          la   10,dscrs
          la   15,alist(sp)
          bal  link,scs$cl
          restore

          lhi  rv,32                    if error return " "
          l    temp,code(ls)
          bm   get←error
          l    rv,get.stop(ls)
get←no←error   equ  *
          lis  temp,0
          st   temp,error←register
          b    popj

          entry     get←code←ptr
get←code←ptr   equ  *
          .ent 0
          la   temp,get.stop(ls)
          l    5,4(ap)
          st   temp,0(5)
          .rtn

*         call ioa$ioars (temp←area,op1,op2)  op1 is a string, op2 is number
*         then copy temp area into op3

     instruction    insert←ioa
          save
          la   temp,io←buffer(sp)       temporary buffer
          st   temp,arg1p(sp)
          li   temp,x'54000050'         char(80) varying
          st   temp,dscrs+8
          l    source,op1(ops)
          bal  link,get←length
          sth  rv,dscrs+6               build up pl/1 type descriptors
          lhi  rv,x'1400'
          sth  rv,dscrs+4
          lis  index,0
          bal  link,get←init
          ar   text←ptr,index
          st   text←ptr,arg2p(sp)
          la   temp,op2(ops)
          st   temp,arg3p(sp)
          li   temp,x'1100001f'         fixed bin(31)
          st   temp,dscrs
          lhi  temp,-16
          st   temp,alist←size(sp)
          save
          la   10,dscrs
          la   15,alist(sp)
          bal  link,scs$ioars←nnl
          restore

          la   temp,io←buffer+2(sp)     make it look like a sine string
          st   temp,op1(ops)
          l    temp,op3(ops)
          st   temp,op2(ops)
          bal  link,insert
          b    popj

*         Store a value in a vbl or temp

     instruction    store
          l    rv,op1(ops)
          l    t2,op2(ops)
          st   rv,0(t2)
          br   link

*         store a value in a vbl

     instruction    estore
          l    rv,op1(ops)              get value
          l    t1,op2(ops)              get vbl
          st   rv,variable.value(t1)
          br   link

*         Creator functions

     instruction    make←buffer
          save
          la   temp,code
          st   temp,arg1p(sp)

*    If this arg is null then a new segment is created else it is a ptr
*    to an already existing segment which the buffer should point to.

          lis  temp,0
          st   temp,segptr(sp)
          la   temp,segptr(sp)
          st   temp,arg2p(sp)
          lhi  temp,12
          st   temp,alist←size(sp)
          la   ap,alist(sp)
          bal  link,$pl1←make←buffer
          restore
          l    rv,code
          br   link

     instruction    make←string
          save
          l    source,op1(ops)
          bal  link,get←length
          lr   5,rv
          ais  5,2                           for length field
          lr   t1,rv
          bal  link,allocate
          oi   rv,string←bits
          sth  t1,string.length(rv)
          l    source,op1(ops)
          lis  index,0
          bal  link,get←init
          la   t1,string.text(rv)
makstr.loop    equ  *
          balr link,get
          b    popj
          stb  char,0(t1)
          ais  t1,1
          bs   makstr.loop

     instruction    intern
          save
          l    source,op1(ops)
          lr   temp,source
          srl  temp,28
          clhi temp,string←type
          bes  int.OK
          bal  link,make←string
          st   rv,op1(ops)
          lr   source,rv

int.OK    lh   t1,string.length(source)
          lr   t2,t1
int.hash  sis  t1,1
          bms  int.got←hash
          lb   char,string.text(source,t1)
          ar   t2,char
          bs   int.hash
int.got←hash   equ  *
          l    t3,op2(ops)                   get array
          dh   t2,array.size+2(t3)           mod array size
          slls t2,2                          full word entries
          l    rv,array.cells(t2,t3)
          l    t5,op1(ops)                   get string we're looking for
          bz   int.new
int.look←loop  equ  *
          l    t4,variable.name(rv)
          lh   t1,string.length(t4)
          ch   t1,string.length(t5)          are the lengths the same
          bnes int.next
int.comp←loop  equ  *
          sis  t1,1
          bm   popj                          we found it
          lb   char,string.text(t4,t1)
          clb  char,string.text(t5,t1)
          bes  int.comp←loop

int.next  l    rv,variable.next(rv)          check next vbl in chain
          bnz  int.look←loop

int.new   lhi  5,variable←size
          bal  link,allocate
          oi   rv,variable←bits
          l    temp,array.cells(t2,t3)
          st   temp,variable.next(rv)
          st   rv,array.cells(t2,t3)
          l    temp,op1(ops)
          st   temp,variable.name(rv)
          lis  temp,0
          st   temp,variable.value(rv)
          b    popj

     instruction    make←window
          save
          lhi  5,window←size
          bal  link,allocate
          oi   rv,window←bits
          lr   t2,rv                         set mark doesn't bash this
          l    source,op1(ops)
          st   source,window.real←text(t2)
          bal  link,make←mark
          st   rv,window.start(t2)
          st   rv,op1(ops)
          st   source,op2(ops)
          lis  temp,0
          st   temp,op3(ops)
          bal  link,set←mark                      To thread them on the buffer
          bal  link,make←mark
          st   rv,window.stop(t2)
          st   rv,op1(ops)
          bal  link,set←mark
          lr   rv,t2
          b    popj

     instruction    define←window
          lis  temp,0
          st   temp,error←register
          lr   t2,link
          l    t1,op1(ops)
          l    source,window.real←text(t1)        get the buffer...
          l    index,op2(ops)
          l    rv,window.start(t1)
          bal  link,sm.gone                  do the set mark
          l    index,op3(ops)
          l    rv,window.stop(t1)
          bal  link,sm.gone                  do the set mark
          lr   rv,t1                         return the defined window
          br   t2                            return

     instruction    make←gnirt
          lr   t1,link
          lhi  5,gnirt←size+16
          bal  link,allocate
        ↔</pre>
</body>
</html>
